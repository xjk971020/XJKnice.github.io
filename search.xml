<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>red-black-tree</title>
      <link href="/2019/07/12/red-black-tree/"/>
      <url>/2019/07/12/red-black-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="TreeSet-amp-红黑树"><a href="#TreeSet-amp-红黑树" class="headerlink" title="TreeSet&amp;红黑树"></a>TreeSet&amp;红黑树</h1><p>本文以Java TreeMap为例，从源代码层面，结合详细的图解，剥茧抽丝地讲解红黑树（Red-Black tree）的插入，删除以及由此产生的调整过程。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p><strong>TreeMap底层通过红黑树（Red-Black tree）实现</strong>，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/1.png" alt></p><p>出于性能原因，TreeMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的：</p><p>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…));</p><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。</strong>具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/2.png" alt></p><p>TreeMap中左旋代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Rotate Left</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            r<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>        r<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">;</span>        r<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>parent <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/3.png" alt></p><p>TreeMap中右旋代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Rotate Right</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> l <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> l<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> p<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">else</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>parent <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/4.png" alt></p><p>具体代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//getEntry()方法</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//不允许key值为null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> k <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用元素的自然顺序</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//向左找</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//向右找</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> k <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用元素的自然顺序</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        parent <span class="token operator">=</span> t<span class="token punctuation">;</span>        cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向左找</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向右找</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并插入新的entry</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调整</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/5.png" alt></p><p>调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//红黑树调整函数fixAfterInsertion()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> y <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果y为null，则视为BLACK</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况1</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 情况2</span>                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 情况2</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 情况3</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> y <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况4</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况4</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 情况5</span>                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况6</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况6</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 情况6</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h4><p>对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到：</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li></ol></blockquote><ol start="2"><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/6.png" alt></p><p>TreeMap中寻找节点后继的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 寻找节点后继函数successor()</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> TreeMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">successor</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ch <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ch <span class="token operator">==</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ch <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。</p><p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。</p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。</strong>现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li></ol></blockquote><ol start="2"><li>删除点p的左右子树都非空。</li></ol><p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。</p><p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 红黑树entry删除函数deleteEntry()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deleteEntry</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 2. 删除点p的左右子树都非空。</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s <span class="token operator">=</span> <span class="token function">successor</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 后继</span>        p<span class="token punctuation">.</span>key <span class="token operator">=</span> s<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>value <span class="token operator">=</span> s<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        p <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> replacement <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>replacement <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 1. 删除点p只有一棵子树非空。</span>        replacement<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>replacement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调整</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 1. 删除点p的左右子树都为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调整</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>parent <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数，</strong>因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="http://cdn.cathetine.cn/blog/images/red-black-tree/7.png" alt></p><p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p><p>删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 情况1</span>                sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况1</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>                <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 情况2</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况2</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 情况3</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况3</span>                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况3</span>                    sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 情况4</span>                x <span class="token operator">=</span> root<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 情况4</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 跟前四种情况对称</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 情况5</span>                sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况5</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>                <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 情况6</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况6</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况7</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况7</span>                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 情况7</span>                    sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 情况7</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 情况8</span>                x <span class="token operator">=</span> root<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 情况8</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">setColor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>前面已经说过TreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法，因此TreeSet的实现非常简单。这里不再赘述。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TreeSet是对TreeMap的简单包装</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">NavigableSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> NavigableMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> m<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dummy value to associate with an Object in the backing Map</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// TreeSet里面有一个TreeMap</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-garbage-collect</title>
      <link href="/2019/07/02/jvm-garbage-collect/"/>
      <url>/2019/07/02/jvm-garbage-collect/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收算法与-JVM-垃圾回收器综述"><a href="#垃圾回收算法与-JVM-垃圾回收器综述" class="headerlink" title="垃圾回收算法与 JVM 垃圾回收器综述"></a>垃圾回收算法与 JVM 垃圾回收器综述</h1><p>我们常说的垃圾回收算法可以分为两部分：对象的查找算法与真正的回收方法。不同回收器的实现细节各有不同，但总的来说基本所有的回收器都会关注如下两个方面：找出所有的存活对象以及清理掉所有的其它对象——也就是那些被认为是废弃或无用的对象。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。其中最主流的四个垃圾回收器分别是：通常用于单 CPU 环境的 Serial GC、Throughput/Parallel GC、CMS GC、G1 GC。</p><p>当我们在讨论垃圾回收器时，往往也会涉及到很多的概念；譬如并行（Parallel）与并发（Concurrent）、Minor GC 与 Major / Full GC。并行指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；并发指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。Minor GC 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快；Major GC 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程），Major GC的速度一般会比Minor GC慢10倍以上。从不同角度分析垃圾回收器，可以将其分为不同的类型：</p><p><img src="/images/garbage-collector/1.jpg" alt></p><p>我们最常用的评价垃圾回收器的指标就是吞吐量与停顿时间，停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务；具体的指标列举如下：</p><ul><li>吞吐量：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%。</li><li>垃圾回收器负载：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值。</li><li>停顿时间：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。</li><li>垃圾回收频率：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。</li><li>反应时间：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。</li><li>堆分配：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾回收器应该有一个合理的堆内存区间划分。</li></ul><p>在对象查找算法的帮助下我们可以找到内存可以被使用的，或者说那些内存是可以回收，更多的时候我们肯定愿意做更少的事情达到同样的目的。</p><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p>在 JDK 1.2 以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（Reachable）状态，程序才能使用它。从 JDK 1.2 版本开始，把对象的引用分为 4 种级别，从而使程序能更加灵活地控制对象的生命周期。这 4 种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><h3 id="StrongReference-强引用"><a href="#StrongReference-强引用" class="headerlink" title="StrongReference: 强引用"></a>StrongReference: 强引用</h3><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。比如下面这段代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当运行至 Object[] objArr = new Object[1000]; 这句时，如果内存不足，JVM 会抛出 OOM 错误也不会回收 object 指向的对象。不过要注意的是，当 fun1 运行完之后，object 和 objArr 都已经不存在了，所以它们指向的对象都会被 JVM 回收。如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。比如 Vector 类的 clear 方法中就是通过将引用赋值为 null 来实现清理工作的：</p><p>``</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Removes the element at the specified position in this Vector.     * Shifts any subsequent elements to the left (subtracts one from their     * indices).  Returns the element that was removed from the Vector.     *     * @throws ArrayIndexOutOfBoundsException if the index is out of range     *         ({@code index &lt; 0 || index >= size()})     * @param index the index of the element to be removed     * @return element that was removed     * @since 1.2     */</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> elementCount<span class="token punctuation">)</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object oldValue <span class="token operator">=</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> numMoved <span class="token operator">=</span> elementCount <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                 numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>elementCount<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Let gc do its work</span><span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference: 软引用"></a>SoftReference: 软引用</h3><p>软引用是用来描述一些有用但并不是必需的对象，在 Java 中用 java.lang.ref.SoftReference 类来表示。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。下面是一个使用示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>SoftReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SoftReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference: 弱引用"></a>WeakReference: 弱引用</h3><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//通知JVM的gc进行垃圾回收</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果为：</p><pre class=" language-text"><code class="language-text">hellonull</code></pre><p>第二个输出结果是 null，这说明只要 JVM 进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h3 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference: 虚引用"></a>PhantomReference: 虚引用</h3><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在 Java 中用 java.lang.ref.PhantomReference 类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>PhantomReference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PhantomReference<span class="token operator">&lt;</span>String<span class="token operator">></span> pr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="对象存活性判断"><a href="#对象存活性判断" class="headerlink" title="对象存活性判断"></a>对象存活性判断</h2><p>常用的对象存活性判断方法有引用计数法与可达性分析，不过由于引用计数法无法解决对象循环引用的问题，因此主流的 JVM 倾向于使用可达性分析。</p><h3 id="Reference-Counting-引用计数"><a href="#Reference-Counting-引用计数" class="headerlink" title="Reference Counting: 引用计数"></a>Reference Counting: 引用计数</h3><p>引用计数器在微软的 COM 组件技术中、Adobe 的 ActionScript3 种都有使用。引用计数器的原理很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p><p><img src="/images/garbage-collector/2.jpg" alt></p><h3 id="引用树遍历"><a href="#引用树遍历" class="headerlink" title="引用树遍历"></a>引用树遍历</h3><p>所谓的引用树本质上是有根的图结构，它沿着对象的根句柄向下查找到活着的节点，并标记下来；其余没有被标记的节点就是死掉的节点，这些对象就是可以被回收的，或者说活着的节点就是可以被拷贝走的，具体要看所在 HeapSize中 的区域以及算法，它的大致示意图如下图所示（注意这里是指针是单向的）：</p><p><img src="/images/garbage-collector/3.jpg" alt></p><p>首先，所有回收器都会通过一个标记过程来对存活对象进行统计。JVM 中用到的所有现代 GC 算法在回收前都会先找出所有仍存活的对象。下图中所展示的JVM中的内存布局可以用来很好地阐释这一概念：</p><p><img src="/images/garbage-collector/4.jpg" alt></p><p>而所谓的GC根对象包括：当前执行方法中的所有本地变量及入参、活跃线程、已加载类中的静态变量、JNI 引用。接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从 GC 根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。存活对象在上图中被标记为蓝色。当标记阶段完成了之后，所有的存活对象都已经被标记完了。其它的那些（上图中灰色的那些）也就是GC根对象不可达的对象，也就是说你的应用不会再用到它们了。这些就是垃圾对象，回收器将会在接下来的阶段中清除它们。</p><p>不过那些发现不能到达 GC Roots 的对象并不会立即回收，在真正回收之前，对象至少要被标记两次。当第一次被发现不可达时，该对象会被标记一次，同时调用此对象的 finalize()方法（如果有）；在第二次被发现不可达后，对象被回收。利用 finalisze()方法，对象可以逃离一次被回收的命运，但是只有一次。逃命方法如下，需要在 finalize() 方法中给自己加一个 GCRoots 中的 hook：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EscapeFromGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> EscapeFromGC hook<span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize mehtod executed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      EscapeFromGC<span class="token punctuation">.</span>hook <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="通用垃圾回收算法"><a href="#通用垃圾回收算法" class="headerlink" title="通用垃圾回收算法"></a>通用垃圾回收算法</h2><p><img src="/images/garbage-collector/5.jpg" alt></p><h3 id="Mark-Sweep-标记-清除算法"><a href="#Mark-Sweep-标记-清除算法" class="headerlink" title="Mark-Sweep: 标记-清除算法"></a>Mark-Sweep: 标记-清除算法</h3><p><img src="/images/garbage-collector/6.jpg" alt></p><p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p><p>从概念上来讲，标记-清除算法使用的方法是最简单的，只需要忽略这些对象便可以了。也就是说当标记阶段完成之后，未被访问到的对象所在的空间都会被认为是空闲的，可以用来创建新的对象。这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量。这种方法还有一个缺陷就是——虽然空闲区域的大小是足够的，但却可能没有一个单一区域能够满足这次分配所需的大小，因此本次分配还是会失败（在Java中就是一次 OutOfMemoryError）。</p><h3 id="Copying-复制算法"><a href="#Copying-复制算法" class="headerlink" title="Copying: 复制算法"></a>Copying: 复制算法</h3><p><img src="/images/garbage-collector/7.jpg" alt></p><p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p><p>Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p><p>标记-复制算法与标记-整理算法非常类似，它们都会将所有存活对象重新进行分配。区别在于重新分配的目标地址不同，复制算法是为存活对象分配了另外的内存 区域作为它们的新家。标记复制算法的优点在于标记阶段和复制阶段可以同时进行。它的缺点是需要一块能容纳下所有存活对象的额外的内存空间。</p><h3 id="Mark-Compact-标记-压缩算法"><a href="#Mark-Compact-标记-压缩算法" class="headerlink" title="Mark-Compact: 标记-压缩算法"></a>Mark-Compact: 标记-压缩算法</h3><p><img src="/images/garbage-collector/8.jpg" alt></p><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p><p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地 清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p><p>标记-压缩算法修复了标记-清除算法的短板——它将所有标记的也就是存活的对象都移动到内存区域的开始位置。这种方法的缺点就是GC暂停的时间会增 长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。相对于标记-清除算法，它的优点也是显而易见的——经过整理之后，新对象的分 配只需要通过指针碰撞便能完成（pointer bumping），相当简单。使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p><h3 id="Incremental-Collecting-增量回收算法"><a href="#Incremental-Collecting-增量回收算法" class="headerlink" title="Incremental Collecting: 增量回收算法"></a>Incremental Collecting: 增量回收算法</h3><p>在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p><p>增量算法现代垃圾回收的一个前身，其基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h3 id="Generational-Collecting-分代回收算法"><a href="#Generational-Collecting-分代回收算法" class="headerlink" title="Generational Collecting: 分代回收算法"></a>Generational Collecting: 分代回收算法</h3><p>分代回收器是增量收集的另一个化身，根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据 每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几 次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一 段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新 生代，因此这种做法也是不可取的。根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</p><h3 id="Concurrent-Collecting-并发回收算法"><a href="#Concurrent-Collecting-并发回收算法" class="headerlink" title="Concurrent Collecting: 并发回收算法"></a>Concurrent Collecting: 并发回收算法</h3><p>所谓的并发回收算法即是指垃圾回收器与应用程序能够交替工作，并发回收 器其实也会暂停，但是时间非常短，它并不会在从开始回收寻找、标记、清楚、压缩或拷贝等方式过程完全暂停服务，它发现有几个时间比较长，一个就是标记，因 为这个回收一般面对的是老年代，这个区域一般很大，而一般来说绝大部分对象应该是活着的，所以标记时间很长，还有一个时间是压缩，但是压缩并不一定非要每 一次做完GC都去压缩的，而拷贝呢一般不会用在老年代，所以暂时不考虑；所以他们想出来的办法就是：第一次短暂停机是将所有对象的根指针找到，这个非常容 易找到，而且非常快速，找到后，此时GC开始从这些根节点标记活着的节点（这里可以采用并行），然后待标记完成后，此时可能有新的 内存申请以及被抛弃（java本身没有内存释放这一概念），此时JVM会记录下这个过程中的增量信息，而对于老年代来说，必须要经过多次在 survivor倒腾后才会进入老年代，所以它在这段时间增量一般来说会非常少，而且它被释放的概率前面也说并不大（JVM如果不是完全做Cache，自 己做pageCache而且发生概率不大不小的pageout和pagein是不适合的）；JVM根据这些增量信息快速标记出内部的节点，也是非常快速 的，就可以开始回收了，由于需要杀掉的节点并不多，所以这个过程也非常快，压缩在一定时间后会专门做一次操作，有关暂停时间在Hotspot版本，也就是 SUN的jdk中都是可以配置的，当在指定时间范围内无法回收时，JVM将会对相应尺寸进行调整，如果你不想让它调整，在设置各个区域的大小时，就使用定 量，而不要使用比例来控制；当采用并发回收算法的时候，一般对于老年代区域，不会等待内存小于10%左右的时候才会发起回收，因为并发回收是允许在回收的 时候被分配，那样就有可能来不及了，所以并发回收的时候，JVM可能会在68%左右的时候就开始启动对老年代GC了。</p><h2 id="JVM-垃圾回收器对比"><a href="#JVM-垃圾回收器对比" class="headerlink" title="JVM 垃圾回收器对比"></a>JVM 垃圾回收器对比</h2><p><img src="/images/garbage-collector/9.jpg" alt></p><p>1999 年随 JDK1.3.1 一起来的是串行方式的 Serial GC，它是第一款垃圾回收器；此后，JDK1.4 和 J2SE1.3 相继发布。2002 年 2 月 26 日，J2SE1.4 发布；Parallel GC 和Concurrent Mark Sweep （CMS）GC 跟随 JDK1.4.2 一起发布，并且 Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。这三个垃圾回收器也是各有千秋，Serial GC 适合最小化地使用内存和并行开销的场景、Parallel GC 适合最大化应用程序吞吐量的场景、CMS GC 适合最小化中断或停顿时间的场景。上图即展示了多种垃圾回收器之间的关系；不过随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有合适的回收器就不能保证应用程序正常进行，而经常造成 STW 停顿的回收器又跟不上实际的需求，所以才会不断地尝试对搜集器进行优化。Garbage First（G1）GC 正是面向这种业务需求所生，它是一个并行回收器，把堆内存分割为很多不相关的区间（Region）；每个区间可以属于老年代或者年轻代，并且每个年龄代区间可以是物理上不连续的。</p><p><img src="/images/garbage-collector/10.jpg" alt></p><p>关于标记阶段有几个关键点是值得注意的：</p><ul><li>开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便 JVM 可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。</li><li>暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。</li></ul><p>当标记阶段完成后，GC开始进入下一阶段，删除不可达对象。</p><h3 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h3><p>串行回收器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。在串行回收器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行回收器却是一个成熟、经过长时间生产环境考验的极为高效的 回收器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行回收器和老年代串行回收器。当 JVM 在 Client 模式下运行时，它是默认的垃圾回收器。老年代串行回收器使用的是标记-压缩算法。和新生代串行回收器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代垃圾回 收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行回收器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以 和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。若要启用老年代串行回收器，可以尝试使用以下参数：-XX:+UseSerialGC: 新生代、老年代都使用串行回收器。</p><p>Serial GC 的工作步骤如下所示：</p><p><img src="/images/garbage-collector/11.jpg" alt></p><h3 id="ParNew-GC"><a href="#ParNew-GC" class="headerlink" title="ParNew GC"></a>ParNew GC</h3><p>并行回收器是工作在新生代的垃圾回收器，它只简单地将串行回收器多线程化。它的回收策略、算法以及参数和串行回收器一样。<br>并行回收器 也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行回收器，老年代使用串行回收器。老年代的并行回收回收器也是一种多线程并发的回收器。和新生代并行回收回收器一样，它也是一种关注吞吐量的回收器。老年代并行回收回收器使用标记-压缩算法，JDK1.6 之后开始启用。</p><h3 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h3><p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供的。使用 -XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收回收器，这是一对非常关注吞吐量的垃圾回收器组合，在对吞吐量敏感的系统中，可以考虑使用。参数 -XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。</p><p>Parallel GC 的工作步骤如下所示：</p><p><img src="/images/garbage-collector/12.jpg" alt></p><h3 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h3><p>CMS( Concurrent Mark-Sweep ) 是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器，适用于对停顿比较敏感，并且有相对较多存活时间较长的对象（老年代较大）的应用程序；不过 CMS 虽然减少了回收的停顿时间，但是降低了堆空间的利用率。CMS GC 采用了 Mark-Sweep 算法，因此经过CMS收集的堆会产生空间碎片；为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当 JVM 分配对象空间的时候，会搜索这个列表找到足够大的空间来存放住这个对象。另一方面，由于 CMS 线程和应用程序线程并发执行，CMS GC 需要更多的 CPU 资源。同时，因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀值。</p><p>CMS GC 工作步骤如下所示：</p><p><img src="/images/garbage-collector/13.jpg" alt></p><ul><li>初始标记(STW initial mark)：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</li><li>并发标记(Concurrent marking)：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li><li>并发预清理(Concurrent precleaning)：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代，或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</li><li>重新标记(STW remark)：这个阶段会暂停虚拟机，回收器线程扫描在CMS堆中剩余的对象。扫描从”跟对象”开始向下追溯，并处理对象关联。</li><li>并发清理(Concurrent sweeping)：清理垃圾对象，这个阶段回收器线程和应用程序线程并发执行。</li><li>并发重置(Concurrent reset)：这个阶段，重置CMS回收器的数据结构，等待下一次垃圾回收。</li></ul><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h3><p>G1 GC 是 JDK 1.7 中正式投入使用的用于取代 CMS 的压缩回收器，它虽然没有在物理上隔断新生代与老生代，但是仍然属于分代垃圾回收器；G1 GC 仍然会区分年轻代与老年代，年轻代依然分有 Eden 区与 Survivor 区。G1 GC 首先将堆分为大小相等的 Region，避免全区域的垃圾收集，然后追踪每个 Region 垃圾堆积的价值大小，在后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region；同时 G1 GC 采用 Remembered Set 来存放 Region 之间的对象引用以及其他回收器中的新生代与老年代之间的对象引用，从而避免全堆扫描。G1 GC 的分区示例如下图所示：</p><p><img src="/images/garbage-collector/14.jpg" alt></p><p>随着 G1 GC 的出现，Java 垃圾回收器通过引入 Region 的概念，从传统的连续堆内存布局设计，逐步走向了物理上不连续但是逻辑上依旧连续的内存块；这样我们能够将某个 Region 动态地分配给 Eden、Survivor、老年代、大对象空间、空闲区间等任意一个。每个 Region 都有一个关联的 Remembered Set（简称RS），RS 的数据结构是 Hash 表，里面的数据是 Card Table （堆中每 512byte 映射在 card table 1byte）。简单的说RS里面存在的是Region中存活对象的指针。当Region中数据发生变化时，首先反映到Card Table中的一个或多个Card上，RS通过扫描内部的Card Table得知Region中内存使用情况和存活对象。在使用Region过程中，如果Region被填满了，分配内存的线程会重新选择一个新的Region，空闲Region被组织到一个基于链表的数据结构（LinkedList）里面，这样可以快速找到新的Region。</p><p>总结而言，G1 GC 的特性如下：</p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力；</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况；</li><li>分代GC：G1依然是一个分代回收器，但是和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li><li>空间整理：G1在回收过程中，会进行适当的对象移动，不像CMS只是简单地标记清理对象。在若干次GC后，CMS必须进行一次碎片整理。而G1不同，它每次回收都会有效地复制对象，减少空间碎片，进而提升内部循环速度；</li><li>可预见性：为了缩短停顿时间，G1建立可预存停顿的模型，这样在用户设置的停顿时间范围内，G1会选择适当的区域进行收集，确保停顿时间不超过用户指定时间。</li></ul><p>G1 GC 的工作步骤如下所示：</p><p><img src="/images/garbage-collector/15.jpg" alt></p><ul><li>初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）</li><li>并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）</li><li>最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log 里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）</li><li>筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-questions</title>
      <link href="/2019/06/30/mysql-questions/"/>
      <url>/2019/06/30/mysql-questions/</url>
      
        <content type="html"><![CDATA[<h1 id="梳理MySQL核心知识点"><a href="#梳理MySQL核心知识点" class="headerlink" title="梳理MySQL核心知识点"></a>梳理MySQL核心知识点</h1><p>数据库的使用，是开发人员的基本功，对它掌握越清晰越深入，你能做的事情就越多。</p><blockquote><p>做业务，要懂基本的SQL语句；<br>做性能优化，要懂索引，懂引擎；<br>做分库分表，要懂主从，懂读写分离…</p></blockquote><p>今天重点梳理一遍以下几方面：</p><ul><li>数据库知识点汇总；</li><li>数据库事务特性和隔离级别；</li><li>详解关系型数据库、索引与锁机制；</li><li>数据库调优与最佳实践；</li><li>面试考察点及加分项。</li></ul><p><strong>知识点汇总</strong></p><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/1.png" alt></p><h2 id="一、数据库的不同类型"><a href="#一、数据库的不同类型" class="headerlink" title="一、数据库的不同类型"></a><strong>一、数据库的不同类型</strong></h2><h3 id="1-常用的关系型数据库"><a href="#1-常用的关系型数据库" class="headerlink" title="1.常用的关系型数据库"></a><strong>1.常用的关系型数据库</strong></h3><ul><li><strong>Oracle：</strong>功能强大，主要缺点就是贵</li><li><strong>MySQL：</strong>互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点</li><li><strong>MariaDB：</strong>是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进</li><li><strong>PostgreSQL：</strong>也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。</li></ul><h3 id="2-NoSQL数据库（非关系型数据库）"><a href="#2-NoSQL数据库（非关系型数据库）" class="headerlink" title="2.NoSQL数据库（非关系型数据库）"></a><strong>2.NoSQL数据库（非关系型数据库）</strong></h3><ul><li><strong>Redis：</strong>提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。</li><li><strong>MongoDB：</strong>一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。</li><li><strong>HBase：</strong>建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。</li><li><strong>Cassandra：</strong>一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。</li><li><strong>Pika：</strong>一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。</li></ul><h3 id="3-NewSQL数据库（新一代关系型数据库）"><a href="#3-NewSQL数据库（新一代关系型数据库）" class="headerlink" title="3.NewSQL数据库（新一代关系型数据库）"></a><strong>3.NewSQL数据库（新一代关系型数据库）</strong></h3><ul><li><strong>TiDB：</strong>开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。</li><li><strong>OceanBase：</strong>OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。</li></ul><h2 id="二、事物特性及事物类型"><a href="#二、事物特性及事物类型" class="headerlink" title="二、事物特性及事物类型"></a><strong>二、事物特性及事物类型</strong></h2><p>后面的详解知识点会展开介绍</p><h2 id="三、数据库的范式"><a href="#三、数据库的范式" class="headerlink" title="三、数据库的范式"></a><strong>三、数据库的范式</strong></h2><p>前关系数据库有六种范式：第一范式、第二范式、第三范式、巴斯-科德范式（BCNF）、第四范式和第五范式。<strong>范式级别越高对数据表的要求越严格。</strong></p><ul><li>第一范式要求最低，只要求表中字段不可用在拆分。</li><li>第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。</li><li>第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。</li><li>一般说来，数据库只需满足第三范式就可以了。</li></ul><h2 id="详解知识点一：数据库事务"><a href="#详解知识点一：数据库事务" class="headerlink" title="详解知识点一：数据库事务"></a>详解知识点一：数据库事务</h2><p><strong>知识点</strong></p><h3 id="▌1-数据库事务特性"><a href="#▌1-数据库事务特性" class="headerlink" title="▌1.数据库事务特性"></a><strong>▌1.数据库事务特性</strong></h3><p>数据库的特性是面试时考察频率非常高的题目，共4个特性：</p><ul><li><strong>原子性：</strong>是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。</li><li><strong>一致性：</strong>是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。</li><li><strong>隔离性：</strong>是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。</li><li><strong>持久性：</strong>是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h3 id="▌2-事物并发问题与隔离级别"><a href="#▌2-事物并发问题与隔离级别" class="headerlink" title="▌2.事物并发问题与隔离级别"></a><strong>▌2.事物并发问题与隔离级别</strong></h3><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/2.png" alt></p><h4 id="a-事务并发问题"><a href="#a-事务并发问题" class="headerlink" title="a.事务并发问题"></a><strong>a.事务并发问题</strong></h4><ul><li><strong>脏读：</strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。</li><li><strong>不可重复读：</strong>不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。</li><li><strong>幻读：</strong>是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。</li></ul><h4 id="b：事务的四种隔离级别"><a href="#b：事务的四种隔离级别" class="headerlink" title="b：事务的四种隔离级别"></a><strong>b：事务的四种隔离级别</strong></h4><p>可以用于解决这几种并发问题。如图右面，由上到下的4种隔离级别由低到高。</p><ul><li><strong>级别1读未提交：</strong>也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。</li><li><strong>级别2读已提交：</strong>就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。</li><li><strong>级别三可重复读：</strong>可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。</li><li><strong>级别四串行化：</strong>这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。</li></ul><h3 id="▌3-事务分类"><a href="#▌3-事务分类" class="headerlink" title="▌3.事务分类"></a><strong>▌3.事务分类</strong></h3><p>共分5大类：</p><ul><li><strong>扁平化事务</strong>：在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。</li><li><strong>带保存点的扁平事务：</strong>为了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。</li><li><strong>链事务：</strong>可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。</li><li><strong>嵌套事务:</strong>由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。</li><li><strong>分布式事务：</strong>是指分布式环境中的扁平化事务。</li></ul><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/3.png" alt></p><p><strong>其中，常用的分布式事务解决方案共4种</strong></p><p><strong>a.XA协议：</strong>是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。</p><p><strong>b.TCC：</strong>是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。</p><p><strong>c.消息事务：</strong>第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。</p><p><strong>d.GTS/Fescar:</strong>阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。</p><h2 id="详解知识点二：MySQL数据库"><a href="#详解知识点二：MySQL数据库" class="headerlink" title="详解知识点二：MySQL数据库"></a><strong>详解知识点二：MySQL数据库</strong></h2><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/4.png" alt></p><h3 id="▌1-常用SQL语句"><a href="#▌1-常用SQL语句" class="headerlink" title="▌1.常用SQL语句"></a><strong>▌1.常用SQL语句</strong></h3><p>需要能手写常用SQL语句，这里没有什么特殊的技巧，根据如图列出的语句类型多做一些练习</p><h3 id="▌2-数据类型"><a href="#▌2-数据类型" class="headerlink" title="▌2.数据类型"></a><strong>▌2.数据类型</strong></h3><p>要知道MySQL都提供哪些基本都数据类型，不同数据类型占用的空间大小。</p><h3 id="▌3-MySQL中主要的存储引擎"><a href="#▌3-MySQL中主要的存储引擎" class="headerlink" title="▌3.MySQL中主要的存储引擎"></a><strong>▌3.MySQL中主要的存储引擎</strong></h3><p>MyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</p><h3 id="▌4-MySQL中的锁"><a href="#▌4-MySQL中的锁" class="headerlink" title="▌4.MySQL中的锁"></a><strong>▌4.MySQL中的锁</strong></h3><p>MyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。</p><p><strong>注：</strong></p><ul><li>共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。</li><li>排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。</li></ul><h3 id="▌5-索引"><a href="#▌5-索引" class="headerlink" title="▌5.索引"></a><strong>▌5.索引</strong></h3><p>后文重点讲解</p><h3 id="▌6-MySQL的存储过程与函数"><a href="#▌6-MySQL的存储过程与函数" class="headerlink" title="▌6.MySQL的存储过程与函数"></a><strong>▌6.MySQL的存储过程与函数</strong></h3><p>存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。</p><p>存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。</p><p>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。</p><p>不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。</p><h3 id="▌7-新特性"><a href="#▌7-新特性" class="headerlink" title="▌7.新特性"></a><strong>▌7.新特性</strong></h3><p>可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。</p><h3 id="▌8-MySQL调优"><a href="#▌8-MySQL调优" class="headerlink" title="▌8.MySQL调优"></a><strong>▌8.MySQL调优</strong></h3><p>后文重点讲解。</p><h2 id="重点讲解一：MySQL索引"><a href="#重点讲解一：MySQL索引" class="headerlink" title="重点讲解一：MySQL索引"></a><strong><em>重点讲解一：MySQL索引</em></strong></h2><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/5.png" alt></p><p>索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。</p><p><strong>但是索引是有如下2个代价的:</strong></p><p>a.需要额外的磁盘空间来保存索引</p><p>b.对于插入、更新、删除等操作由于更新索引会增加额外的开销</p><p>因此索引比较适合用在读多写少的场景。</p><h3 id="▌1-MySQL索引类型"><a href="#▌1-MySQL索引类型" class="headerlink" title="▌1.MySQL索引类型"></a><strong>▌1.MySQL索引类型</strong></h3><p>如左面的模块，共分为5类：</p><ul><li><strong>唯一索引：</strong>就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。</li><li><strong>主键索引：</strong>是一种特殊的唯一索引，但是它不允许出现空值。</li><li><strong>普通索引：</strong>与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。</li><li><strong>联合索引：</strong>就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。</li><li><strong>全文索引：</strong>前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。</li></ul><h3 id="▌2-索引实现"><a href="#▌2-索引实现" class="headerlink" title="▌2.索引实现"></a><strong>▌2.索引实现</strong></h3><p>如右面的模块，索引实现共分4种形式：</p><ul><li><strong>B+树实现</strong>：b+树比较适合用作’&gt;’或’&lt;’这样的范围查询，是MySQL中最常使用的一种索引实现。</li><li><strong>R-tree：</strong>是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。</li><li><strong>Hash：</strong>是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。</li><li><strong>FullText：</strong>就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。</li></ul><h2 id="重点讲解二：MySQL调优"><a href="#重点讲解二：MySQL调优" class="headerlink" title="重点讲解二：MySQL调优"></a><strong>重点讲解二：MySQL调优</strong></h2><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/6.png" alt></p><p>MySQL的调优也是研发人员需要掌握的一项技能</p><p><strong>一般MySQL调优有图中的4个纬度：</strong></p><ul><li>针对数据库设计、表结构设计以及索引设置纬度进行的优化；</li><li>对业务中使用的SQL语句进行优化，例如调整Where查询条件；</li><li>对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;</li><li>对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。</li></ul><p>这四个纬度从优化的成本角度来讲，从左到右优化成本逐渐升高；从优化效果角度来看，从右到左优化的效果更高。</p><p>对于研发人员来说，前两个纬度与业务息息相关，因此需要重点掌握，后两个纬度更适合DBA进行深入学习，简单了解就好。</p><p><strong>本文将重点关注前两个纬度</strong></p><p><img src="http://cdn.cathetine.cn/blog/images/mysql-questions/7.png" alt></p><h3 id="▌1-表结构和索引的优化"><a href="#▌1-表结构和索引的优化" class="headerlink" title="▌1.表结构和索引的优化"></a><strong>▌1.表结构和索引的优化</strong></h3><p>如左面的模块，应该掌握如下6个原则：</p><p><strong>第1个原则</strong>：要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；</p><p><strong>第2个原则</strong>：要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；</p><p><strong>第3个原则</strong>：可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；</p><p><strong>第4个原则</strong>：是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；</p><p><strong>第5个原则</strong>：要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；</p><p><strong>第6个原则</strong>：列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</p><h3 id="▌2-SQL语句进行优化的原则"><a href="#▌2-SQL语句进行优化的原则" class="headerlink" title="▌2.SQL语句进行优化的原则"></a><strong>▌2.SQL语句进行优化的原则</strong></h3><p>如右面的模块，共分5个原则：</p><p><strong>第1个原则：</strong>要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；</p><p><strong>第2个原则</strong>：要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；</p><p><strong>第3个原则</strong>：要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；</p><p><strong>第4个原则</strong>：是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；</p><p><strong>第5个原则</strong>：是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</p><p>以上为数据库操作须掌握的内容，可以进行差缺补漏，希望对研发人员有一定的帮助。</p><h2 id="面试考察点"><a href="#面试考察点" class="headerlink" title="面试考察点"></a><strong>面试考察点</strong></h2><p><strong><em>1.</em></strong>必须了解数据库的基本原理、使用场景以及常用队列、数据库的特点。MySQL提供了多种引擎可以支持事务型与非事务型的关系对象库服务等等。</p><p><strong><em>2.</em></strong>要深刻理解数据库事务的ACID特性，了解并发事务可能导致的并发问题和不同的数据库隔离级别如何解决这些并发问题。</p><p><strong><em>3.</em></strong>要掌握常用的MySQL语句，比如WHERE条件查询语句、JOIN关联语句、ORDER BY排序语句等等。还要熟悉常用的自带函数，例如SUM、COUNT等等。</p><p><strong><em>4.</em></strong>要了解MySQL数据库不同引擎的特点及不同类型的索引实现。比如最长使用的InnoDB非常擅长事务处理，MyISAM比较适合非事务的简单查询场景。比如知道MySQL的唯一索引、联合索引、全文索引等不同索引类型，以及最长使用等B+树索引实现等等。</p><h2 id="面试加分项"><a href="#面试加分项" class="headerlink" title="面试加分项"></a><strong>面试加分项</strong></h2><p><strong><em>1.</em></strong>要了解新特性，例如MySQL8.0中提供了窗口函数来支持新的查询方式；支持通用表表达式，使复杂查询中的嵌入表语句更加清晰等等。</p><p><strong><em>2.</em></strong>要知道数据库表设计原则，如果有过线上业务数据库的设计经验就更好了，你能够知道如何对容量进行评估，也知道适当分库分表来保证未来服务的可扩展性，这会对面试起到积极的影响。</p><p><strong><em>3.</em></strong>最好有过数据库调优经验，例如明明建立了索引的语句，但是查询效率还是很慢，通过Explain分析发现表中有多个索引，MySQL的优化器选用了错误的索引，导致查询效率偏低，然后通过在SQL语句中使用Use Index来指定索引解决。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-propagation</title>
      <link href="/2019/06/30/spring-propagation/"/>
      <url>/2019/06/30/spring-propagation/</url>
      
        <content type="html"><![CDATA[<h1 id="简述Spring支持的7种事务传播行为"><a href="#简述Spring支持的7种事务传播行为" class="headerlink" title="简述Spring支持的7种事务传播行为"></a>简述Spring支持的7种事务传播行为</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-什么是事务传播行为？"><a href="#1-什么是事务传播行为？" class="headerlink" title="1. 什么是事务传播行为？"></a>1. 什么是事务传播行为？</h3><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><p>用伪代码说明：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//doSomething</span> <span class="token punctuation">}</span> <span class="token annotation punctuation">@Transaction</span><span class="token punctuation">(</span>Propagation<span class="token operator">=</span>XXX<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//doSomething</span> <span class="token punctuation">}</span></code></pre><p>代码中<code>methodA()</code>方法嵌套调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transaction(Propagation=XXX)</code>设置决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p><h3 id="2-Spring中七种事务传播行为"><a href="#2-Spring中七种事务传播行为" class="headerlink" title="2. Spring中七种事务传播行为"></a>2. Spring中七种事务传播行为</h3><blockquote><p>propagation_required（xml文件中为required)<br>表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）</p></blockquote><p>比如你在执行insert,update,delete方法时,中间只要遇到异常,将自动回滚</p><hr><blockquote><p>propagation_supports(xml文件中为supports）<br>表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行</p></blockquote><p>不管是否有事务都会执行</p><hr><blockquote><p>propagation_mandatory(xml文件中为mandatory）<br>表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常</p></blockquote><p>必须有事务,否则异常</p><hr><blockquote><p>propagation_nested(xml文件中为nested)<br>表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同propagation_required的一样</p></blockquote><p>可以这么理解,内嵌套独立事务中自行提交和回滚,不会影响外嵌套.</p><p>但是,外嵌套抛出异常回滚,内嵌套也跟着回滚.</p><hr><blockquote><p>propagation_never（xml文件中为never)<br>表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常</p></blockquote><p>存在事务,则抛出异常</p><hr><blockquote><p>propagation_requires_new(xml文件中为requires_new）<br>表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。</p></blockquote><p>理解是当一个事务在运行时,第二个事务必须等第一个事务提交或回滚完了才执行(就是2要执行必须等1提交或回滚完)</p><hr><blockquote><p>propagation_not_supported（xml文件中为not_supported）<br>表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行</p></blockquote><p>方法不能有事务,如果有,那就等他提交或回滚才执行</p><hr><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>文中代码以传统三层结构中两层呈现，即Service和Dao层，由Spring负责依赖注入和注解式事务管理，DAO层由Mybatis实现，你也可以使用任何喜欢的方式，例如，Hibernate,JPA,JDBCTemplate等。数据库使用的是MySQL数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。</p><p>首先我们在数据库中创建两张表：</p><p><strong>user1</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>user1<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INTEGER</span> UNSIGNED <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span></code></pre><p><strong>user2</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>user2<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INTEGER</span> UNSIGNED <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span></code></pre><p>然后编写相应的Bean和DAO层代码：</p><p><strong>User1</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//get和set方法省略...</span><span class="token punctuation">}</span></code></pre><p><strong>User2</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//get和set方法省略...</span><span class="token punctuation">}</span></code></pre><p><strong>User1Mapper</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">User1Mapper</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span>User1 record<span class="token punctuation">)</span><span class="token punctuation">;</span>    User1 <span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//其他方法省略...</span><span class="token punctuation">}</span></code></pre><p><strong>User2Mapper</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">User2Mapper</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span>User2 record<span class="token punctuation">)</span><span class="token punctuation">;</span>    User2 <span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//其他方法省略...</span><span class="token punctuation">}</span></code></pre><p>最后也是具体验证的代码由service层实现，下面我们分情况列举。</p><h3 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRED</code>属性。</p><p><strong>User1Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span>User1 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>User2Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiredException</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h4><p>此场景外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_exception_required_required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法2：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_required_required_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiredException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”、“李四”均插入。</td><td align="left">外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td align="left">2</td><td align="left">“张三”插入，“李四”未插入。</td><td align="left">外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h4><p>外围方法开启事务，这个是使用率比较高的场景。</p><p><strong>验证方法1：</strong></p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_required_required</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法2：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_required_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiredException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法3：</strong></p><pre><code>    @Transactional    @Override    public void transaction_required_required_exception_try(){        User1 user1=new User1();        user1.setName(&quot;张三&quot;);        user1Service.addRequired(user1);        User2 user2=new User2();        user2.setName(&quot;李四&quot;);        try {            user2Service.addRequiredException(user2);        } catch (Exception e) {            System.out.println(&quot;方法回滚&quot;);        }    }</code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”、“李四”均未插入。</td><td align="left">外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td align="left">2</td><td align="left">“张三”、“李四”均未插入。</td><td align="left">外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</td></tr><tr><td align="left">3</td><td align="left">“张三”、“李四”均未插入。</td><td align="left">外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被catch不被外围方法感知，整个事务依然回滚。</td></tr></tbody></table><p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，所有Propagation.REQUIRED修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p><h3 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRES_NEW</code>属性。<br><strong>User1Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNew</span><span class="token punctuation">(</span>User1 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequired</span><span class="token punctuation">(</span>User1 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>User2Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNew</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-1-场景一"><a href="#2-1-场景一" class="headerlink" title="2.1 场景一"></a>2.1 场景一</h4><p>外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre><code>    @Override    public void notransaction_exception_requiresNew_requiresNew(){        User1 user1=new User1();        user1.setName(&quot;张三&quot;);        user1Service.addRequiresNew(user1);        User2 user2=new User2();        user2.setName(&quot;李四&quot;);        user2Service.addRequiresNew(user2);        throw new RuntimeException();    }</code></pre><p><strong>验证方法2：</strong></p><pre><code>    @Override    public void notransaction_requiresNew_requiresNew_exception(){        User1 user1=new User1();        user1.setName(&quot;张三&quot;);        user1Service.addRequiresNew(user1);        User2 user2=new User2();        user2.setName(&quot;李四&quot;);        user2Service.addRequiresNewException(user2);    }</code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”插入，“李四”插入。</td><td align="left">外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</td></tr><tr><td align="left">2</td><td align="left">“张三”插入，“李四”未插入</td><td align="left">外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="2-2-场景二"><a href="#2-2-场景二" class="headerlink" title="2.2 场景二"></a>2.2 场景二</h4><p>外围方法开启事务。</p><p><strong>验证方法1：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_required_requiresNew_requiresNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法2：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_requiresNew_requiresNew_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法3：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_required_requiresNew_requiresNew_exception_try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addRequired</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNew</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            user2Service<span class="token punctuation">.</span><span class="token function">addRequiresNewException</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”未插入，“李四”插入，“王五”插入。</td><td align="left">外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</td></tr><tr><td align="left">2</td><td align="left">“张三”未插入，“李四”插入，“王五”未插入。</td><td align="left">外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</td></tr><tr><td align="left">3</td><td align="left">“张三”插入，“李四”插入，“王五”未插入。</td><td align="left">外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</td></tr></tbody></table><p><strong>结论：在外围方法开启事务的情况下Propagation.REQUIRES_NEW修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p><h3 id="3-PROPAGATION-NESTED"><a href="#3-PROPAGATION-NESTED" class="headerlink" title="3.PROPAGATION_NESTED"></a>3.PROPAGATION_NESTED</h3><p>我们为User1Service和User2Service相应方法加上<code>Propagation.NESTED</code>属性。<br><strong>User1Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User1ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User1Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNested</span><span class="token punctuation">(</span>User1 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user1Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>User2Service方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User2ServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">User2Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略其他...</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNested</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNestedException</span><span class="token punctuation">(</span>User2 user<span class="token punctuation">)</span><span class="token punctuation">{</span>        user2Mapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h4><p>此场景外围方法没有开启事务。</p><p><strong>验证方法1：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_exception_nested_nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法2：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notransaction_nested_nested_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”、“李四”均插入。</td><td align="left">外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td align="left">2</td><td align="left">“张三”插入，“李四”未插入。</td><td align="left">外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.NESTED和Propagation.REQUIRED作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p><h4 id="3-2-场景二"><a href="#3-2-场景二" class="headerlink" title="3.2 场景二"></a>3.2 场景二</h4><p>外围方法开启事务。</p><p><strong>验证方法1：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Transactional</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_exception_nested_nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法2：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Transactional</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_nested_nested_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>验证方法3：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Transactional</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transaction_nested_nested_exception_try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        User1 user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user1Service<span class="token punctuation">.</span><span class="token function">addNested</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        User2 user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            user2Service<span class="token punctuation">.</span><span class="token function">addNestedException</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>分别执行验证方法，结果：</p><table><thead><tr><th align="left">验证方法序号</th><th align="left">数据库结果</th><th align="left">结果分析</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">“张三”、“李四”均未插入。</td><td align="left">外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td align="left">2</td><td align="left">“张三”、“李四”均未插入。</td><td align="left">外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</td></tr><tr><td align="left">3</td><td align="left">“张三”插入、“李四”未插入。</td><td align="left">外围方法开启事务，内部事务为外围事务的子事务，插入“张三”内部方法抛出异常，可以单独对子事务回滚。</td></tr></tbody></table><p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下Propagation.NESTED修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务。</strong></p><h3 id="4-REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#4-REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title="4. REQUIRED,REQUIRES_NEW,NESTED异同"></a>4. REQUIRED,REQUIRES_NEW,NESTED异同</h3><p>由“1.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</strong></p><p>由“2.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</strong></p><h2 id="模拟用例"><a href="#模拟用例" class="headerlink" title="模拟用例"></a>模拟用例</h2><p>介绍了这么多事务传播行为，我们在实际工作中如何应用呢？下面我来举一个示例：</p><p>假设我们有一个注册的方法，方法中调用添加积分的方法，如果我们希望添加积分不会影响注册流程（即添加积分执行失败回滚不能使注册方法也回滚），我们会这样写：</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Service</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Transactional</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                membershipPointService<span class="token punctuation">.</span><span class="token function">addPoint</span><span class="token punctuation">(</span>Point point<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//省略...</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//省略...</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//省略...</span>   <span class="token punctuation">}</span></code></pre><p>我们还规定注册失败要影响<code>addPoint()</code>方法（注册方法回滚添加积分方法也需要回滚），那么<code>addPoint()</code>方法就需要这样实现：</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Service</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MembershipPointServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MembershipPointService</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPoint</span><span class="token punctuation">(</span>Point point<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                recordService<span class="token punctuation">.</span><span class="token function">addRecord</span><span class="token punctuation">(</span>Record record<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//省略...</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//省略...</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//省略...</span>   <span class="token punctuation">}</span></code></pre><p>我们注意到了在<code>addPoint()</code>中还调用了<code>addRecord()</code>方法，这个方法用来记录日志。他的实现如下：</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Service</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RecordServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RecordService</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NOT_SUPPORTED<span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRecord</span><span class="token punctuation">(</span>Record record<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//省略...</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//省略...</span>   <span class="token punctuation">}</span></code></pre><p>我们注意到<code>addRecord()</code>方法中<code>propagation = Propagation.NOT_SUPPORTED</code>，因为对于日志无所谓精确，可以多一条也可以少一条，所以<code>addRecord()</code>方法本身和外围<code>addPoint()</code>方法抛出异常都不会使<code>addRecord()</code>方法回滚，并且<code>addRecord()</code>方法抛出异常也不会影响外围<code>addPoint()</code>方法的执行。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-memory-allocate</title>
      <link href="/2019/06/29/java-memory-allocate/"/>
      <url>/2019/06/29/java-memory-allocate/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存分配区域"><a href="#Java内存分配区域" class="headerlink" title="Java内存分配区域"></a>Java内存分配区域</h1><p><strong><font color="red">下面是面试官可能在“Java内存区域”知识点问你的问题:</font></strong></p><p><strong>基本问题：</strong></p><ul><li><strong>介绍下Java内存区域（运行时数据区）。</strong></li><li><strong>Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li><li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li></ul><p><strong>拓展问题:</strong></p><ul><li><strong>String类和常量池</strong></li><li><strong>8种基本类型的包装类和常量池</strong></li></ul><h2 id="1-概述（为什么要学习Java内存区域）"><a href="#1-概述（为什么要学习Java内存区域）" class="headerlink" title="1 概述（为什么要学习Java内存区域）"></a>1 概述（为什么要学习Java内存区域）</h2><p>对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个new 操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制权利交给Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2 运行时数据区域"></a>2 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/1.jpg" alt></p><p>这些组成部分一些事线程私有的，其他的则是线程共享的。</p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存</li></ul><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。</strong></p><p><strong>Java内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong></p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</strong> 在HotSpot虚拟机中和Java虚拟机栈合二为一。</p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：在细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>HotSpot虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为HotSpot虚拟机设计团队用永久代来实现方法区而已，这样HotSpot虚拟机的垃圾收集器就可以像管理Java堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域。</strong></p><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入的<strong>NIO(New Input/Output)类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在Java堆和Native堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="3-HotSpot虚拟机对象探秘"><a href="#3-HotSpot虚拟机对象探秘" class="headerlink" title="3 HotSpot虚拟机对象探秘"></a>3 HotSpot虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><h3 id="3-1-对象的创建（重点）"><a href="#3-1-对象的创建（重点）" class="headerlink" title="3.1 对象的创建（重点）"></a>3.1 对象的创建（重点）</h3><p>下图便是Java对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。  </p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/4.jpg" alt></p><p><strong>①类加载检查：</strong> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/3.jpg" alt></p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</li></ul><p><strong>③初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。<strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， <code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在Hotspot虚拟机中，对象在内存中的布局可以分为3快区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希吗、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="3-3-对象的访问定位（重点）"><a href="#3-3-对象的访问定位（重点）" class="headerlink" title="3.3 对象的访问定位（重点）"></a>3.3 对象的访问定位（重点）</h3><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><p><strong>1. 句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/4.jpg" alt></p><p><strong>2. 直接指针：</strong> 如果使用直接指针访问，那么Java堆对像的布局中就必须考虑如何防止访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/5.jpg" alt></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="4-重点补充内容（重点）"><a href="#4-重点补充内容（重点）" class="headerlink" title="4 重点补充内容（重点）"></a>4 重点补充内容（重点）</h2><h3 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h3><p><strong>1 String对象的两种创建方式：</strong></p><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre><p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。</p><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/6.jpg" alt></p><p>记住：只要使用new方法，便需要创建新的对象。</p><p><strong>2 String类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern方String.intern() 是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          String s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         String s3 <span class="token operator">=</span> <span class="token string">"计算机"</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算机      </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，       </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true，因为两个都是常量池中的String对</span></code></pre><p><strong>3 String字符串拼接</strong></p><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"str"</span><span class="token punctuation">;</span>          String str2 <span class="token operator">=</span> <span class="token string">"ing"</span><span class="token punctuation">;</span>          String str3 <span class="token operator">=</span> <span class="token string">"str"</span> <span class="token operator">+</span> <span class="token string">"ing"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池中的对象        </span>String str4 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在堆上创建的新的对象        </span>String str5 <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池中的对象          </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false          </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true         </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str4 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre><p><img src="http://cdn.cathetine.cn/blog/images/Java-memory/7.jpg" alt></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的花，可以使用 StringBuilder 或者 StringBuffer。</p><h3 id="String-s1-new-String-“abc”-这句话创建了几个对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个对象？"></a>String s1 = new String(“abc”);这句话创建了几个对象？</h3><p><strong>创建了两个对象。</strong></p><p><strong>验证：</strong></p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 堆内存的地值值        </span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同       </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出true</span></code></pre><p><strong>结果：</strong></p><blockquote><ol><li><code>false</code></li><li><code>true</code></li></ol></blockquote><p><strong>解释：</strong></p><p>先有字符串”abc”放入常量池，然后 new 了一份字符串”abc”放入Java堆(字符串常量”abc”在编译期就已经确定放入常量池，而 Java 堆上的”abc”是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的”abc”。</p><h3 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h3><ul><li><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</strong></li><li><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></li></ul><pre class=" language-java"><code class="language-java">Integer i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>        Integer i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出true        </span>Integer i11 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>Integer i22 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出false</span>Double i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>Double i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出false</span></code></pre><p><strong>Integer 缓存源代码：</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外  *的其他值。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>                   <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>应用场景：</strong></p><ol><li>Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li><li>Integer i1 = new Integer(40);这种情况下会创建新的对象，所以尽量避免使用这种方式。</li></ol><pre class=" language-java"><code class="language-java">Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出fals</span></code></pre><p><strong>Integer比较更丰富的一个例子:</strong></p><pre class=" language-java"><code class="language-java">Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span> Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Integer i4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2+i3   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 <span class="token operator">+</span> i3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i4   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"40=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </code></pre><p>结果：</p><blockquote><ol><li><code>i1=i2   true</code></li><li><code>i1=i2+i3   true</code></li><li><code>i1=i4   false</code></li><li><code>i4=i5   false</code></li><li><code>i4=i5+i6   true</code></li><li><code>40=i5+i6   true</code></li></ol></blockquote><p>解释：</p><p>语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSO原理与实现</title>
      <link href="/2019/06/22/sso-yuan-li-yu-shi-xian/"/>
      <url>/2019/06/22/sso-yuan-li-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="项目中的单点登录是如何实现的？"><a href="#项目中的单点登录是如何实现的？" class="headerlink" title="项目中的单点登录是如何实现的？"></a>项目中的单点登录是如何实现的？</h1><h2 id="一、单系统登录机制"><a href="#一、单系统登录机制" class="headerlink" title="一、单系统登录机制"></a>一、单系统登录机制</h2><h3 id="1、http无状态协议"><a href="#1、http无状态协议" class="headerlink" title="1、http无状态协议"></a>1、http无状态协议</h3><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/1.jpg" alt></p><p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。</p><h3 id="2、会话机制"><a href="#2、会话机制" class="headerlink" title="2、会话机制"></a>2、会话机制</h3><p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/2.jpg" alt></p><p>服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式。</p><ol><li>请求参数</li><li>cookie</li></ol><p>将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息。</p><p>tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/3.jpg" alt></p><h3 id="3、登录状态"><a href="#3、登录状态" class="headerlink" title="3、登录状态"></a>3、登录状态</h3><p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下。</p><pre class=" language-java"><code class="language-java">HttpSession session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"isLogin"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用户再次访问时，tomcat在会话对象中查看登录状态</p><pre class=" language-java"><code class="language-java">HttpSession session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"isLogin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实现了登录状态的浏览器请求服务器模型如下图描述。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/4.jpg" alt></p><p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p><hr><h2 id="二、多系统的复杂性"><a href="#二、多系统的复杂性" class="headerlink" title="二、多系统的复杂性"></a>二、多系统的复杂性</h2><p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/5.jpg" alt></p><p>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/6.jpg" alt></p><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/7.jpg" alt></p><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p><hr><h2 id="三、单点登录"><a href="#三、单点登录" class="headerlink" title="三、单点登录"></a>三、单点登录</h2><p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/8.jpg" alt></p><p>下面对上图简要描述。</p><ol><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数；</li><li>sso认证中心发现用户未登录，将用户引导至登录页面；</li><li>用户输入用户名密码提交登录申请；</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌；</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）；</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效；</li><li>sso认证中心校验令牌，返回有效，注册系统1；</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源；</li><li>用户访问系统2的受保护资源；</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数；</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌；</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效；</li><li>sso认证中心校验令牌，返回有效，注册系统2；</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源。</li></ol><p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系。</p><ol><li>局部会话存在，全局会话一定存在；</li><li>全局会话存在，局部会话不一定存在；</li><li>全局会话销毁，局部会话必须销毁。</li></ol><p>你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数。</p><h3 id="2、注销"><a href="#2、注销" class="headerlink" title="2、注销"></a>2、注销</h3><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/9.jpg" alt></p><p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。</p><p>下面对上图简要说明。</p><ol><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li><li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>sso认证中心向所有注册系统发起注销请求</li><li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li><li>sso认证中心引导用户至登录页面</li></ol><h2 id="四、部署图"><a href="#四、部署图" class="headerlink" title="四、部署图"></a>四、部署图</h2><p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/10.jpg" alt></p><p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以。</p><h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><p>只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）。</p><p><strong>sso-client</strong></p><ol><li>拦截子系统未登录用户请求，跳转至sso认证中心；</li><li>接收并存储sso认证中心发送的令牌；</li><li>与sso-server通信，校验令牌的有效性；</li><li>建立局部会话；</li><li>拦截用户注销请求，向sso认证中心发送注销请求；</li><li>接收sso认证中心发出的注销请求，销毁局部会话。</li></ol><p><strong>sso-server</strong></p><ol><li>验证用户的登录信息；</li><li>创建全局会话；</li><li>创建授权令牌；</li><li>与sso-client通信发送令牌；</li><li>校验sso-client令牌有效性；</li><li>系统注册；</li><li>接收sso-client注销请求，注销所有会话。</li></ol><p>接下来，我们按照原理来一步步实现sso吧！</p><h3 id="1、sso-client拦截未登录请求"><a href="#1、sso-client拦截未登录请求" class="headerlink" title="1、sso-client拦截未登录请求"></a>1、sso-client拦截未登录请求</h3><p>Java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span>ServletRequest request<span class="token punctuation">,</span> ServletResponse response<span class="token punctuation">,</span> FilterChain chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ServletException <span class="token punctuation">{</span>    HttpServletRequest req <span class="token operator">=</span> <span class="token punctuation">(</span>HttpServletRequest<span class="token punctuation">)</span> request<span class="token punctuation">;</span>    HttpServletResponse res <span class="token operator">=</span> <span class="token punctuation">(</span>HttpServletResponse<span class="token punctuation">)</span> response<span class="token punctuation">;</span>    HttpSession session <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"isLogin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//跳转至sso认证中心</span>    res<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"sso-server-url-with-system-url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、sso-server拦截未登录请求"><a href="#2、sso-server拦截未登录请求" class="headerlink" title="2、sso-server拦截未登录请求"></a>2、sso-server拦截未登录请求</h3><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样。</p><h3 id="3、sso-server验证用户登录信息"><a href="#3、sso-server验证用户登录信息" class="headerlink" title="3、sso-server验证用户登录信息"></a>3、sso-server验证用户登录信息</h3><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> HttpServletRequest req<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkLoginInfo</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    req<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"isLogin"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、sso-server创建授权令牌"><a href="#4、sso-server创建授权令牌" class="headerlink" title="4、sso-server创建授权令牌"></a>4、sso-server创建授权令牌</h3><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子。</p><pre class=" language-java"><code class="language-java">String token <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5、sso-client取得令牌并校验"><a href="#5、sso-client取得令牌并校验" class="headerlink" title="5、sso-client取得令牌并校验"></a>5、sso-client取得令牌并校验</h3><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 请求附带token参数</span>String token <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 去sso认证中心校验token</span>    <span class="token keyword">boolean</span> verifyResult <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">"sso-server-verify-url"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>verifyResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"sso-server-url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档。</p><pre class=" language-java"><code class="language-java">HttpPost httpPost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span><span class="token string">"sso-server-verify-url-with-token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HttpResponse httpResponse <span class="token operator">=</span> httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>httpPost<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="6、sso-server接收并处理校验令牌请求"><a href="#6、sso-server接收并处理校验令牌请求" class="headerlink" title="6、sso-server接收并处理校验令牌请求"></a>6、sso-server接收并处理校验令牌请求</h3><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）。</p><p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p><p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。</p><p><img src="http://cdn.cathetine.cn/blog/images/sso-yuanli/11.jpg" alt></p><h3 id="7、sso-client校验令牌成功创建局部会话"><a href="#7、sso-client校验令牌成功创建局部会话" class="headerlink" title="7、sso-client校验令牌成功创建局部会话"></a>7、sso-client校验令牌成功创建局部会话</h3><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>verifyResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>    session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"isLogin"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求。</p><h3 id="8、注销过程"><a href="#8、注销过程" class="headerlink" title="8、注销过程"></a>8、注销过程</h3><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求。</p><pre class=" language-java"><code class="language-java">String logout <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"logout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>logout <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>ssoServer<span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">logout</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">)</span> <span class="token punctuation">{</span>    HttpSession session <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>session <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        session<span class="token punctuation">.</span><span class="token function">invalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//触发LogoutListener</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"redirect:/"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogoutListener</span> <span class="token keyword">implements</span> <span class="token class-name">HttpSessionListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sessionCreated</span><span class="token punctuation">(</span>HttpSessionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sessionDestroyed</span><span class="token punctuation">(</span>HttpSessionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过httpClient向所有注册系统发送注销请求</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单点登录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap&amp;ConcurrentHashMap</title>
      <link href="/2019/06/21/hashmap-concurrenthashmap/"/>
      <url>/2019/06/21/hashmap-concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-HashMap-ConcurrentHashMap-原理及源码"><a href="#Java-HashMap-ConcurrentHashMap-原理及源码" class="headerlink" title="Java-HashMap, ConcurrentHashMap 原理及源码"></a>Java-HashMap, ConcurrentHashMap 原理及源码</h2><p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><hr><h3 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h3><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p><p>Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p><strong>capacity：</strong>当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p><strong>loadFactor：</strong>负载因子，默认为 0.75。</p><p><strong>threshold：</strong>扩容的阈值，等于 capacity * loadFactor</p><h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当插入第一个元素的时候，需要先初始化数组大小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 求 key 的 hash 值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 找到对应的数组下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span>    <span class="token comment" spellcheck="true">//    如果有，直接覆盖，put 方法返回旧值就结束了</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保证数组大小一定是 2 的 n 次方。</span>    <span class="token comment" spellcheck="true">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算扩容阈值：capacity * loadFactor</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 算是初始化数组吧</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ignore</span><span class="token punctuation">}</span></code></pre><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span>    <span class="token keyword">return</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 扩容，后面会介绍一下</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 扩容以后，重新计算 hash 值</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新计算扩容后的新的下标</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 往下看</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新的数组</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将原来数组中的值迁移到新的更大的数组中</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><h4 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length – 1)。</li><li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// </span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>getEntry(key):</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h3><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 “<strong>槽</strong>” 来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">></span> MAX_SEGMENTS<span class="token punctuation">)</span>        concurrencyLevel <span class="token operator">=</span> MAX_SEGMENTS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Find power-of-two sizes best matching arguments</span>    <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>sshift<span class="token punctuation">;</span>        ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span>    <span class="token comment" spellcheck="true">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// initialCapacity 是设置整个 map 初始的大小，</span>    <span class="token comment" spellcheck="true">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span>    <span class="token comment" spellcheck="true">// 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span>        <span class="token operator">++</span>c<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span>    <span class="token comment" spellcheck="true">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> MIN_SEGMENT_TABLE_CAPACITY<span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>        cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建 Segment 数组，</span>    <span class="token comment" spellcheck="true">// 并创建数组的第一个元素 segment[0]</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s0 <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token punctuation">[</span>ssize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往数组写入 segment[0]</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> SBASE<span class="token punctuation">,</span> s0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ordered write of segments[0]</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> ss<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 – 4 = 28，segmentMask 为 16 – 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li></ul><h4 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 计算 key 的 hash 值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span>    <span class="token comment" spellcheck="true">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，</span>    <span class="token comment" spellcheck="true">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span>    <span class="token comment" spellcheck="true">// ensureSegment(j) 对 segment[j] 进行初始化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span>getObject          <span class="token comment" spellcheck="true">// nonvolatile; recheck</span>         <span class="token punctuation">(</span>segments<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  in ensureSegment</span>        s <span class="token operator">=</span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 插入新值到 槽 s 中</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span>    <span class="token comment" spellcheck="true">//    先看主流程，后面还会具体介绍这部分内容</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span>        <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    V oldValue<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个是 segment 内部的数组</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再利用 hash 值，求应该放置的数组下标</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// first 是数组该位置处的链表的表头</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first <span class="token operator">=</span> <span class="token function">entryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                K k<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                    <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 覆盖旧值</span>                        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 继续顺着链表走</span>                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span>                <span class="token comment" spellcheck="true">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> c <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> threshold <span class="token operator">&amp;&amp;</span> tab<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>                    <span class="token function">rehash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 扩容后面也会具体分析</span>                <span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span>                    <span class="token comment" spellcheck="true">// 其实就是将新的节点设置成原链表的表头</span>                    <span class="token function">setEntryAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>                count <span class="token operator">=</span> c<span class="token punctuation">;</span>                oldValue <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 解锁</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">ensureSegment</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>    <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// raw offset</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> seg<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里看到为什么之前要初始化 segment[0] 了，</span>        <span class="token comment" spellcheck="true">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span>        <span class="token comment" spellcheck="true">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span>        Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> proto <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cap <span class="token operator">=</span> proto<span class="token punctuation">.</span>table<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">float</span> lf <span class="token operator">=</span> proto<span class="token punctuation">.</span>loadFactor<span class="token punctuation">;</span>        <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cap <span class="token operator">*</span> lf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化 segment[k] 内部的数组</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 再次检查一遍该槽是否被其他线程初始化了。</span>            Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>lf<span class="token punctuation">,</span> threshold<span class="token punctuation">,</span> tab<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>seg <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> u<span class="token punctuation">,</span> null<span class="token punctuation">,</span> seg <span class="token operator">=</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> seg<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><blockquote><p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">scanAndLockForPut</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first <span class="token operator">=</span> <span class="token function">entryForHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// negative while locating node</span>    <span class="token comment" spellcheck="true">// 循环获取锁</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to recheck first below</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// speculatively create node</span>                    <span class="token comment" spellcheck="true">// 进到这里说明数组该位置的链表是空的，没有任何元素</span>                    <span class="token comment" spellcheck="true">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span>                    node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>                retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">// 顺着链表往下走</span>                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span>        <span class="token comment" spellcheck="true">//    lock() 是阻塞方法，直到获取锁后返回</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>retries <span class="token operator">></span> MAX_SCAN_RETRIES<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>retries <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                 <span class="token comment" spellcheck="true">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span>                 <span class="token comment" spellcheck="true">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span>                 <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">entryForHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e <span class="token operator">=</span> first <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// re-traverse if entry changed</span>            retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p><h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2 倍</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建新数组</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span>        <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span>    <span class="token keyword">int</span> sizeMask <span class="token operator">=</span> newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldCapacity <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// e 是链表的第一个元素</span>        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> oldTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算应该放置在新数组中的位置，</span>            <span class="token comment" spellcheck="true">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 该位置处只有一个元素，那比较好办</span>                newTable<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Reuse consecutive sequence at same slot</span>                <span class="token comment" spellcheck="true">// e 是链表表头</span>                HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// idx 是当前链表的头结点 e 的新位置</span>                <span class="token keyword">int</span> lastIdx <span class="token operator">=</span> idx<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last <span class="token operator">=</span> next<span class="token punctuation">;</span>                     last <span class="token operator">!=</span> null<span class="token punctuation">;</span>                     last <span class="token operator">=</span> last<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> last<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> lastIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        lastIdx <span class="token operator">=</span> k<span class="token punctuation">;</span>                        lastRun <span class="token operator">=</span> last<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span>                newTable<span class="token punctuation">[</span>lastIdx<span class="token punctuation">]</span> <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 下面的操作是处理 lastRun 之前的节点，</span>                <span class="token comment" spellcheck="true">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> e<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    V v <span class="token operator">=</span> p<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> h <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span>                    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n <span class="token operator">=</span> newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    newTable<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> v<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span>    <span class="token keyword">int</span> nodeIndex <span class="token operator">=</span> node<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> sizeMask<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// add the new node</span>    node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newTable<span class="token punctuation">[</span>nodeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</strong></p><h4 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// manually integrate access methods to reduce overhead</span>    HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. hash 值</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">>>></span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> SSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> SBASE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 根据 hash 找到对应的 segment</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>tab <span class="token operator">=</span> s<span class="token punctuation">.</span>table<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3. 找到segment 内部数组相应位置的链表，遍历</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span> UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span>                 <span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> TBASE<span class="token punctuation">)</span><span class="token punctuation">;</span>             e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            K k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ul><li><p>put 操作的线程安全性</p></li><li><p>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</p></li><li><p>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</p></li><li><p>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</p></li><li><p>remove 操作的线程安全性</p></li></ul><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。</p><p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p><p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p><hr><h3 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 <strong>Entry</strong> 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h4 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><span class="token comment" spellcheck="true">// 第四个参数 evict 我们这里不关心</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span>    <span class="token comment" spellcheck="true">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 数组该位置有数据</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 到这里，说明数组该位置上是一个链表</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span>                    <span class="token comment" spellcheck="true">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// e!=null 说明存在旧值的key与要插入的key"相等"</span>        <span class="token comment" spellcheck="true">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 对应数组扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将数组大小扩大一倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 将阈值扩大一倍</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用新的数组大小初始化新的数组</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 开始遍历原数组，进行数据迁移。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果是红黑树，具体我们就不展开了</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">// 这块是处理链表的情况，</span>                    <span class="token comment" spellcheck="true">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span>                    <span class="token comment" spellcheck="true">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 第一条链表</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key.</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断第一个节点是不是就是需要的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 判断是否是红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 链表遍历</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h3><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p><p>ConcurrentHashMap结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这构造函数里，什么都不干</span><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>               MAXIMUM_CAPACITY <span class="token operator">:</span>               <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h4 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到 hash 值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于记录相应链表的长度</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果数组"空"，进行数组初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 初始化数组，后面会详细介绍</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找该 hash 值对应的数组下标，得到第一个节点 f</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果数组该位置为空，</span>            <span class="token comment" spellcheck="true">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span>            <span class="token comment" spellcheck="true">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span>            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 到这里就是说，f 是该位置的头结点，而且不为空</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取数组该位置的头结点的监视器锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 头结点的 hash 值大于 0，说明是链表</span>                        <span class="token comment" spellcheck="true">// 用于累加，记录链表的长度</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 遍历链表</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            K ek<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">// 到了链表的最末端，将这个新值放到链表的最后面</span>                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                          value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 红黑树</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 调用红黑树的插值方法插入新节点</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// binCount != 0 说明上面在做链表操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span>                    <span class="token comment" spellcheck="true">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span>                    <span class="token comment" spellcheck="true">//    具体源码我们就不看了，扩容部分后面说</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// </span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化的"功劳"被其他线程"抢去"了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lost initialization race; just spin</span>        <span class="token comment" spellcheck="true">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// DEFAULT_CAPACITY 默认初始容量是 16</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 初始化数组，长度为 16 或初始化时提供的长度</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 将这个数组赋值给 table，table 是 volatile 的</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 如果 n 为 16 的话，那么这里 sc = 12</span>                    <span class="token comment" spellcheck="true">// 其实就是 0.75 * n</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> b<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// MIN_TREEIFY_CAPACITY 为 64</span>        <span class="token comment" spellcheck="true">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 后面我们再详细分析这个方法</span>            <span class="token function">tryPresize</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// b 是头结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>hash <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 下面就是遍历链表，建立一颗红黑树</span>                    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hd <span class="token operator">=</span> null<span class="token punctuation">,</span> tl <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> b<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>                            <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span>                                              null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                            hd <span class="token operator">=</span> p<span class="token punctuation">;</span>                        <span class="token keyword">else</span>                            tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                        tl <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 将红黑树设置到数组相应位置中</span>                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryPresize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span>        <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> c<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                        table <span class="token operator">=</span> nt<span class="token punctuation">;</span>                        sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0.75 * n</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;=</span> sc <span class="token operator">||</span> n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>                    sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>                    transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span>                <span class="token comment" spellcheck="true">//    此时 nextTab 不为 null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span>            <span class="token comment" spellcheck="true">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span>            <span class="token comment" spellcheck="true">//  调用 transfer 方法，此时 nextTab 参数为 null</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span>                                         <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行** 1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16</span>    <span class="token comment" spellcheck="true">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span>    <span class="token comment" spellcheck="true">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>    <span class="token comment" spellcheck="true">// 如果 nextTab 为 null，先进行一次初始化</span>    <span class="token comment" spellcheck="true">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span>    <span class="token comment" spellcheck="true">//       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 容量翻倍</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// nextTable 是 ConcurrentHashMap 中的属性</span>        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span>        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ForwardingNode 翻译过来就是正在被迁移的 Node</span>    <span class="token comment" spellcheck="true">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span>    <span class="token comment" spellcheck="true">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span>    <span class="token comment" spellcheck="true">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span>    <span class="token comment" spellcheck="true">//    所以它其实相当于是一个标志。</span>    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span>    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>    <span class="token comment" spellcheck="true">/*     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看     *      */</span>    <span class="token comment" spellcheck="true">// i 是位置索引，bound 是边界，注意是从后往前</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这个 while 真的是不好理解</span>        <span class="token comment" spellcheck="true">// advance 为 true 表示可以进行下一个位置的迁移了</span>        <span class="token comment" spellcheck="true">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将 transferIndex 值赋给 nextIndex</span>            <span class="token comment" spellcheck="true">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span>                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 所有的迁移操作已经完成</span>                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将新的 nextTab 赋值给 table 属性，完成迁移</span>                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span>                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>            <span class="token comment" spellcheck="true">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span>            <span class="token comment" spellcheck="true">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 任务结束，方法退出</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span>                <span class="token comment" spellcheck="true">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了</span>                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span>                        <span class="token comment" spellcheck="true">// 需要将链表一分为二，</span>                        <span class="token comment" spellcheck="true">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span>                        <span class="token comment" spellcheck="true">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span>                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 其中的一个链表放在新数组的位置 i</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 另一个链表放在新数组的位置 i+n</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span>                        <span class="token comment" spellcheck="true">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// advance 设置为 true，代表该位置已经迁移完毕</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 红黑树的迁移</span>                        TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lo <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hi <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span>                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将 ln 放置在新数组的位置 i</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将 hn 放置在新数组的位置 i+n</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span>                        <span class="token comment" spellcheck="true">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// advance 设置为 true，代表该位置已经迁移完毕</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h4 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p><p>1.计算 hash 值</p><p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p><p>3.根据该位置处结点性质进行相应查找</p><ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> K ek<span class="token punctuation">;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断头结点是否就是我们需要的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历链表</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-concurrent</title>
      <link href="/2019/06/20/java-concurrent/"/>
      <url>/2019/06/20/java-concurrent/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发编程基础"><a href="#Java并发编程基础" class="headerlink" title="Java并发编程基础"></a>Java并发编程基础</h1><hr><h3 id="1、在java中守护线程和本地线程区别？"><a href="#1、在java中守护线程和本地线程区别？" class="headerlink" title="1、在java中守护线程和本地线程区别？"></a>1、在java中守护线程和本地线程区别？</h3><p>java中的线程分为两种：<font color="red">守护线程</font>和<font color="red">用户线程</font>。</p><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolean)；true则把该线程设置为守护线程，反之则为用户线程。</p><p>Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p><strong>两者区别：</strong></p><p>虚拟机（JVM）何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。</p><p>也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。</p><p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。</p><hr><h3 id="2、死锁与活锁的区别，死锁与饥饿的区别？"><a href="#2、死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="2、死锁与活锁的区别，死锁与饥饿的区别？"></a>2、死锁与活锁的区别，死锁与饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 </p><p>产生死锁的必要条件： </p><ul><li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </li><li>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 </li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p><strong>活锁：</strong>任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿：</strong>一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。 </p><p>Java中导致饥饿的原因：</p><ul><li>高优先级线程吞噬所有的低优先级线程的CPU时间。</li><li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。</li></ul><hr><h3 id="3、Java中用到的线程调度算法是什么？"><a href="#3、Java中用到的线程调度算法是什么？" class="headerlink" title="3、Java中用到的线程调度算法是什么？"></a>3、Java中用到的线程调度算法是什么？</h3><p>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。</p><hr><h3 id="4、为什么使用Executor框架？"><a href="#4、为什么使用Executor框架？" class="headerlink" title="4、为什么使用Executor框架？"></a>4、为什么使用Executor框架？</h3><ul><li>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</li><li>调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li><li>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li></ul><hr><h3 id="5、在Java中Executor和Executors的区别？"><a href="#5、在Java中Executor和Executors的区别？" class="headerlink" title="5、在Java中Executor和Executors的区别？"></a>5、在Java中Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。 </p><p>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><hr><h3 id="6、什么是原子操作？"><a href="#6、什么是原子操作？" class="headerlink" title="6、什么是原子操作？"></a>6、什么是原子操作？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 </p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。 </p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 </p><p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p><hr><h3 id="7、Java-Concurrency-API中的Lock接口是什么？对比同步它有什么优势？"><a href="#7、Java-Concurrency-API中的Lock接口是什么？对比同步它有什么优势？" class="headerlink" title="7、Java Concurrency API中的Lock接口是什么？对比同步它有什么优势？"></a>7、Java Concurrency API中的Lock接口是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。 </p><p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><ul><li>可以使锁更公平</li><li>可以使线程在等待锁的时候响应中断</li><li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li><li>可以在不同的范围，以不同的顺序获取和释放锁</li></ul><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的、定时的、可中断的、可多条件队列的锁操作。另外Lock的实现类基本都支持非公平锁和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><hr><h3 id="8、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#8、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="8、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>8、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>阻塞队列是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供了7个阻塞队列。分别是： </p><ul><li><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p></li><li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p></li><li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p></li><li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p></li><li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p></li><li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p></li></ul><p>Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait 、notify、notifyAll、sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。 </p><p>BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><hr><h3 id="9、什么是FutureTask"><a href="#9、什么是FutureTask" class="headerlink" title="9、什么是FutureTask?"></a>9、什么是FutureTask?</h3><p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。</p><p>只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><hr><h3 id="10、什么是并发容器的实现？"><a href="#10、什么是并发容器的实现？" class="headerlink" title="10、什么是并发容器的实现？"></a>10、什么是并发容器的实现？</h3><p>何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector、Hashtable、Collections.synchronizedSet、synchronizedList等方法返回的容器。 </p><p>可以通过查看Vector，Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。</p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p><hr><h3 id="11、多线程同步和互斥有几种实现方法，都是什么？"><a href="#11、多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="11、多线程同步和互斥有几种实现方法，都是什么？"></a>11、多线程同步和互斥有几种实现方法，都是什么？</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。 </p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。 </p><p>用户模式下的方法有：原子操作、临界区。内核模式下的方法有：事件、信号量、互斥量。</p><hr><h3 id="12、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#12、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="12、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>12、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 </p><p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p><hr><h3 id="13、Java中你怎样唤醒一个阻塞的线程？"><a href="#13、Java中你怎样唤醒一个阻塞的线程？" class="headerlink" title="13、Java中你怎样唤醒一个阻塞的线程？"></a>13、Java中你怎样唤醒一个阻塞的线程？</h3><p>在Java发展史上曾经使用suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。 </p><p>解决方案可以使用以对象为目标的阻塞，即利用Object类的wait()和notify()方法实现线程阻塞。 </p><p>首先，wait、notify方法是针对对象的，调用任意对象的wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify方法必须在synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用wait、notify方法的对象是同一个，如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行wait阻塞后当前线程就将之前获取的对象锁释放。</p><hr><h3 id="14、CycliBarriar和CountdownLatch有什么区别？"><a href="#14、CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="14、CycliBarriar和CountdownLatch有什么区别？"></a>14、CycliBarriar和CountdownLatch有什么区别？</h3><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。 </p><p>Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。 </p><p>你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。 </p><p>所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 </p><p>CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止</p><p>CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><hr><h3 id="15、什么是不可变对象，它对写并发应用有什么帮助？"><a href="#15、什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="15、什么是不可变对象，它对写并发应用有什么帮助？"></a>15、什么是不可变对象，它对写并发应用有什么帮助？</h3><p>不可变对象即对象一旦被创建它的状态就不能改变，反之即为可变对象。 不可变对象的类即为不可变类。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p><p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p>不可变对象永远是线程安全的。</p><p>只有满足如下状态，一个对象才是不可变的；</p><ul><li>它的状态不能在创建后再被修改；</li><li>所有域都是final类型；并且，</li><li>它被正确创建（创建期间没有发生this引用的逸出）。</li></ul><hr><h3 id="16、Java中用到的线程调度算法是什么？"><a href="#16、Java中用到的线程调度算法是什么？" class="headerlink" title="16、Java中用到的线程调度算法是什么？"></a>16、Java中用到的线程调度算法是什么？</h3><p>计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.</p><p>有两种调度模型：分时调度模型和抢占式调度模型。 </p><p>分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。</p><p>java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p><hr><h3 id="17、什么是线程组，为什么在Java中不推荐使用？"><a href="#17、什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="17、什么是线程组，为什么在Java中不推荐使用？"></a>17、什么是线程组，为什么在Java中不推荐使用？</h3><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p><hr><h3 id="18、为什么使用Executor框架比使用应用创建和管理线程好？"><a href="#18、为什么使用Executor框架比使用应用创建和管理线程好？" class="headerlink" title="18、为什么使用Executor框架比使用应用创建和管理线程好？"></a>18、为什么使用Executor框架比使用应用创建和管理线程好？</h3><p>为什么要使用Executor线程池框架？</p><ol><li>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</li><li>调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li><li>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li></ol><p>使用Executor线程池框架的优点：</p><ol><li>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。</li><li>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。</li><li>框架中已经有定时、定期、单线程、并发数控制等功能。</li><li>综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。</li></ol><hr><h3 id="19、如何停止一个正在运行的线程？"><a href="#19、如何停止一个正在运行的线程？" class="headerlink" title="19、如何停止一个正在运行的线程？"></a>19、如何停止一个正在运行的线程？</h3><ul><li>使用共享变量的方式</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p><ul><li>使用interrupt方法终止线程</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用stop()方法，而是使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p><hr><h3 id="20、notify-和notifyAll-有什么区别？"><a href="#20、notify-和notifyAll-有什么区别？" class="headerlink" title="20、notify()和notifyAll()有什么区别？"></a>20、notify()和notifyAll()有什么区别？</h3><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p><p>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p><hr><h3 id="21、什么是Daemon线程？它有什么意义？"><a href="#21、什么是Daemon线程？它有什么意义？" class="headerlink" title="21、什么是Daemon线程？它有什么意义？"></a>21、什么是Daemon线程？它有什么意义？</h3><p>所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p><p>反过来说， 只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行finally子句的情况下就会终止其run()方法。</p><p>比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</p><hr><h3 id="22、什么是可重入锁？"><a href="#22、什么是可重入锁？" class="headerlink" title="22、什么是可重入锁？"></a>22、什么是可重入锁？</h3><p>举例来说明锁的可重入性：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnReentrant</span><span class="token punctuation">{</span>    Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//do something</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>outer中调用了inner，outer先锁住了lock，这样inner就不能再获取lock。其实调用outer的线程已经获取了lock锁，但是不能在inner中重复利用已经获取的锁资源，这种锁即称之为 不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p><p>synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p><hr><h3 id="23、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#23、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="23、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>23、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h3><p>如果其他方法没有synchronized的话，其他线程是可以进入的。</p><p>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><hr><h3 id="24、乐观锁和悲观锁的理解及如何实现？"><a href="#24、乐观锁和悲观锁的理解及如何实现？" class="headerlink" title="24、乐观锁和悲观锁的理解及如何实现？"></a>24、乐观锁和悲观锁的理解及如何实现？</h3><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><hr><h3 id="25、SynchronizedMap-和-ConcurrentHashMap有什么区别？"><a href="#25、SynchronizedMap-和-ConcurrentHashMap有什么区别？" class="headerlink" title="25、SynchronizedMap 和 ConcurrentHashMap有什么区别？"></a>25、SynchronizedMap 和 ConcurrentHashMap有什么区别？</h3><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。</p><p>ConcurrentHashMap使用分段锁来保证在多线程下的性能。ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。 </p><p>另外ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><hr><h3 id="26、CopyOnWriteArrayList可以用于什么应用场景？"><a href="#26、CopyOnWriteArrayList可以用于什么应用场景？" class="headerlink" title="26、CopyOnWriteArrayList可以用于什么应用场景？"></a>26、CopyOnWriteArrayList可以用于什么应用场景？</h3><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li></ul><p>CopyOnWriteArrayList透露的思想</p><ul><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ul><hr><h3 id="27、volatile有什么用？能否用一句话说明下volatile的应用场景？"><a href="#27、volatile有什么用？能否用一句话说明下volatile的应用场景？" class="headerlink" title="27、volatile有什么用？能否用一句话说明下volatile的应用场景？"></a>27、volatile有什么用？能否用一句话说明下volatile的应用场景？</h3><p>volatile保证内存可见性和禁止指令重排。</p><p>volatile用于多线程环境下的单次操作(单次读或者单次写)。</p><hr><h3 id="28、为什么代码会重排序？"><a href="#28、为什么代码会重排序？" class="headerlink" title="28、为什么代码会重排序？"></a>28、为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li>在单线程环境下不能改变程序运行的结果；</li><li>存在数据依赖关系的不允许重排序</li></ul><p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p><hr><h3 id="29、在java中wait和sleep方法的不同？"><a href="#29、在java中wait和sleep方法的不同？" class="headerlink" title="29、在java中wait和sleep方法的不同？"></a>29、在java中wait和sleep方法的不同？</h3><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><p>直接了解的深入一点吧：</p><p><img src="http://pt2ta7frm.bkt.clouddn.com/blog/images/MultiProcess/1.jpg" alt></p><p>在Java中线程的状态一共被分成6种：</p><p><strong>初始态：</strong></p><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p><p><strong>运行态：</strong></p><p>在Java中，运行态包括就绪态和运行态。 </p><p>就绪态该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中。 </p><p>运行态获得CPU执行权，正在执行的线程。由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</p><p><strong>阻塞态：</strong></p><p>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在Java中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。PS：锁、IO、Socket等都资源。</p><p><strong>等待态：</strong></p><p>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。也有一个等待队列存放所有等待态的线程。线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p><p><strong>超时等待态：</strong></p><p>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；进入该状态后释放CPU执行权 和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p><p><strong>终止态：</strong></p><p>线程执行结束后的状态。</p><p>注意：</p><ul><li>wait()方法会释放CPU执行权和占有的锁。</li><li>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li><li>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li><li>wait和notify必须配套使用，即必须使用同一把锁调用；</li><li>wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</li></ul><hr><h3 id="30、一个线程运行时发生异常会怎样？"><a href="#30、一个线程运行时发生异常会怎样？" class="headerlink" title="30、一个线程运行时发生异常会怎样？"></a>30、一个线程运行时发生异常会怎样？</h3><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><hr><h3 id="31、Java中notify-和-notifyAll有什么区别？"><a href="#31、Java中notify-和-notifyAll有什么区别？" class="headerlink" title="31、Java中notify 和 notifyAll有什么区别？"></a>31、Java中notify 和 notifyAll有什么区别？</h3><p>notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p><hr><h3 id="32、为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#32、为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="32、为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>32、为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h3><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><hr><h3 id="33、Java中interrupted-和-isInterrupted方法的区别？"><a href="#33、Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="33、Java中interrupted 和 isInterrupted方法的区别？"></a>33、Java中interrupted 和 isInterrupted方法的区别？</h3><p>interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>interrupted查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。</p><p>isInterrupted仅仅是查询当前线程的中断状态</p><hr><h3 id="34、为什么wait和notify方法要在同步块中调用？"><a href="#34、为什么wait和notify方法要在同步块中调用？" class="headerlink" title="34、为什么wait和notify方法要在同步块中调用？"></a>34、为什么wait和notify方法要在同步块中调用？</h3><p>Java API强制要求这样做，如果你不这么做，会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p><hr><h3 id="35、Java中的同步集合与并发集合有什么区别？"><a href="#35、Java中的同步集合与并发集合有什么区别？" class="headerlink" title="35、Java中的同步集合与并发集合有什么区别？"></a>35、Java中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。</p><p>Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><hr><h3 id="35、怎么检测一个线程是否拥有锁？"><a href="#35、怎么检测一个线程是否拥有锁？" class="headerlink" title="35、怎么检测一个线程是否拥有锁？"></a>35、怎么检测一个线程是否拥有锁？</h3><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><hr><h3 id="36、Thread类中的yield方法有什么作用？"><a href="#36、Thread类中的yield方法有什么作用？" class="headerlink" title="36、Thread类中的yield方法有什么作用？"></a>36、Thread类中的yield方法有什么作用？</h3><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><hr><h3 id="37、Java中ConcurrentHashMap的并发度是什么？"><a href="#37、Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="37、Java中ConcurrentHashMap的并发度是什么？"></a>37、Java中ConcurrentHashMap的并发度是什么？</h3><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p><p>在JDK8后，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p><hr><h3 id="38、Java线程池中submit-和-execute-方法有什么区别？"><a href="#38、Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="38、Java线程池中submit() 和 execute()方法有什么区别？"></a>38、Java线程池中submit() 和 execute()方法有什么区别？</h3><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p><p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p><hr><h3 id="39、什么是阻塞式方法？"><a href="#39、什么是阻塞式方法？" class="headerlink" title="39、什么是阻塞式方法？"></a>39、什么是阻塞式方法？</h3><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p><hr><h3 id="40、volatile-变量和-atomic-变量有什么不同？"><a href="#40、volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="40、volatile 变量和 atomic 变量有什么不同？"></a>40、volatile 变量和 atomic 变量有什么不同？</h3><p>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</p><p>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><hr><h3 id="41、如何让正在运行的线程暂停一段时间？"><a href="#41、如何让正在运行的线程暂停一段时间？" class="headerlink" title="41、如何让正在运行的线程暂停一段时间？"></a>41、如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p><hr><h3 id="42、你对线程优先级的理解是什么？"><a href="#42、你对线程优先级的理解是什么？" class="headerlink" title="42、你对线程优先级的理解是什么？"></a>42、你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><p>java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><hr><h3 id="43、什么是线程调度器和时间分片？"><a href="#43、什么是线程调度器和时间分片？" class="headerlink" title="43、什么是线程调度器和时间分片？"></a>43、什么是线程调度器和时间分片？</h3><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。<br>同上一个问题，线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><p>时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。</p><hr><h3 id="44、为什么线程通信的方法wait-、notify-和notifyAll-被定义在Object-类里？"><a href="#44、为什么线程通信的方法wait-、notify-和notifyAll-被定义在Object-类里？" class="headerlink" title="44、为什么线程通信的方法wait()、notify()和notifyAll()被定义在Object 类里？"></a>44、为什么线程通信的方法wait()、notify()和notifyAll()被定义在Object 类里？</h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><hr><h3 id="45、为什么Thread类的sleep-和yield-方法是静态的？"><a href="#45、为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="45、为什么Thread类的sleep()和yield ()方法是静态的？"></a>45、为什么Thread类的sleep()和yield ()方法是静态的？</h3><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><hr><h3 id="46、同步方法和同步块，哪个是更好的选择？"><a href="#46、同步方法和同步块，哪个是更好的选择？" class="headerlink" title="46、同步方法和同步块，哪个是更好的选择？"></a>46、同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><hr><h3 id="47、如何创建守护线程？"><a href="#47、如何创建守护线程？" class="headerlink" title="47、如何创建守护线程？"></a>47、如何创建守护线程？</h3><p>使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。</p><hr><h3 id="48、什么是Java-Timer-类？如何创建一个有特定时间间隔的任务？"><a href="#48、什么是Java-Timer-类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="48、什么是Java Timer 类？如何创建一个有特定时间间隔的任务？"></a>48、什么是Java Timer 类？如何创建一个有特定时间间隔的任务？</h3><p>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 </p><p>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 </p><p>目前有开源的Qurtz可以用来创建定时任务。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8-time-api</title>
      <link href="/2019/06/16/java8-time-api/"/>
      <url>/2019/06/16/java8-time-api/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8新特性之日期-时间API"><a href="#Java8新特性之日期-时间API" class="headerlink" title="Java8新特性之日期-时间API"></a>Java8新特性之日期-时间API</h1><p>在Java8之前的版本中，我们处理时间类型常常使用的是java.util包下的Date类。</p><p>但使用Date类却有诸多的弊端，如：java.util.Date是非线程安全的，所有的日期类都是可变的；日期/时间类的定义并不一致，在java.util和java.sql的包下都含有Date类，在开发过程中极易出错； 日期类并不提供国际化，没有时区支持。</p><p>为了解决以上问题，Java8在java.time包下提供了很多新的API，常用的类包括LocalDate、LocalTime、LocalDateTime，用以处理日期，时间，日期/时间等</p><hr><h2 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h2><p>LocalDate是一个不可变类，在不考虑时区的情况下可以对日期（不包括时间）进行各种操作，它的默认格式是yyyy-MM-dd</p><h3 id="获取当前日期以及年、月、日"><a href="#获取当前日期以及年、月、日" class="headerlink" title="获取当前日期以及年、月、日"></a>获取当前日期以及年、月、日</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取当前日期以及年、月、日</span>LocalDate localDate <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> year <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> month <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> day <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"年："</span> <span class="token operator">+</span> year <span class="token operator">+</span> <span class="token string">"  月："</span> <span class="token operator">+</span> month <span class="token operator">+</span> <span class="token string">"  日："</span> <span class="token operator">+</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>当前日期：2018-12-12<br>年：2018  月：12  日：12</p></blockquote><h3 id="获取指定的日期"><a href="#获取指定的日期" class="headerlink" title="获取指定的日期"></a>获取指定的日期</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取指定的日期</span>LocalDate specifiedDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"指定日期："</span> <span class="token operator">+</span> specifiedDay<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>指定日期：2008-08-18</p></blockquote><h3 id="比较两个时间的先后顺序以及是否相等"><a href="#比较两个时间的先后顺序以及是否相等" class="headerlink" title="比较两个时间的先后顺序以及是否相等"></a>比较两个时间的先后顺序以及是否相等</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java">LocalDate localDate <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate otherDate <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//equals方法用于比较两个日期是否相等</span><span class="token keyword">if</span><span class="token punctuation">(</span>localDate<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>otherDate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localDate与otherDate相等！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//isAfter和isBefore方法用于比较两个日期前后顺序</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>localDate<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>otherDate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localDate晚于otherDate！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>localDate<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>otherDate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localDate早于otherDate！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><blockquote><p>localDate晚于otherDate！</p></blockquote><h3 id="对日期做加减运算"><a href="#对日期做加减运算" class="headerlink" title="对日期做加减运算"></a>对日期做加减运算</h3><pre class=" language-java"><code class="language-java">LocalDate localDate <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2年后日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">plusYears</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6月后日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">plusMonths</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3周后日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">plusWeeks</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"15天后日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2年前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">minusYears</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6月前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">minusMonths</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3周前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">minusWeeks</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"15天前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>2年后日期：2020-12-12<br>6月后日期：2019-06-12<br>3周后日期：2019-01-02<br>15天后日期：2018-12-27</p></blockquote><blockquote><p>2年前日期：2016-12-12<br>6月前日期：2018-06-12<br>3周前日期：2018-11-21<br>15天前日期：2018-11-27</p></blockquote><h3 id="获取日期间隔的天数"><a href="#获取日期间隔的天数" class="headerlink" title="获取日期间隔的天数"></a>获取日期间隔的天数</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取某年份的第N天的日期</span>LocalDate specialDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">ofYearDay</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2018年的第100天："</span> <span class="token operator">+</span> specialDay<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取两个日期的间隔天数</span><span class="token keyword">long</span> intervalDay <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> specialDay<span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"间隔天数： "</span> <span class="token operator">+</span> intervalDay<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>2018年的第100天：2018-04-10<br>间隔天数：246</p></blockquote><hr><h2 id="LocalTime类"><a href="#LocalTime类" class="headerlink" title="LocalTime类"></a>LocalTime类</h2><p>LocalTime与LocalDate一样，也是一个不可变的类，默认格式是hh: mm: ss.zzz，它提供了对时间的各种操作</p><h3 id="获取当前时间以及自定义时间"><a href="#获取当前时间以及自定义时间" class="headerlink" title="获取当前时间以及自定义时间"></a>获取当前时间以及自定义时间</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取当前时间、时、分、秒以及自定义时间</span>LocalTime localTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> hour <span class="token operator">=</span> localTime<span class="token punctuation">.</span><span class="token function">getHour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> minute <span class="token operator">=</span> localTime<span class="token punctuation">.</span><span class="token function">getMinute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> second <span class="token operator">=</span> localTime<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"时："</span> <span class="token operator">+</span> hour <span class="token operator">+</span> <span class="token string">"  分："</span> <span class="token operator">+</span> minute <span class="token operator">+</span> <span class="token string">"  秒："</span> <span class="token operator">+</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取自定义时间</span>LocalTime specifiedTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义时间："</span> <span class="token operator">+</span> specifiedTime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>当前时间：13:45:59.039<br>时：13  分：45  秒：59<br>自定义时间：15:30:45</p></blockquote><h3 id="比较两个时间的先后顺序"><a href="#比较两个时间的先后顺序" class="headerlink" title="比较两个时间的先后顺序"></a>比较两个时间的先后顺序</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//equals方法比较两个时间是否相等</span><span class="token keyword">if</span><span class="token punctuation">(</span>localTime<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>specifiedTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localTime与specifiedTime相等！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//isAfter、isBefore方法比较两个时间的先后顺序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>localTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>specifiedTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localTime晚于specifiedTime！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>localTime<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>specifiedTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"localTime早于specifiedTime！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><blockquote><p>localTime早于specifiedTime！</p></blockquote><h3 id="对时间做加减运算"><a href="#对时间做加减运算" class="headerlink" title="对时间做加减运算"></a>对时间做加减运算</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java">LocalTime localTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2小时后时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"30分钟后时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">plusMinutes</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"500秒后日时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2小时前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">minusHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"30分钟前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">minusMinutes</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"500秒前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">.</span><span class="token function">minusSeconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>当前时间：14:10:15.666<br>2小时后时间：16:10:15.666<br>30分钟后时间：14:40:15.666<br>500秒后时间：14:18:35.666</p></blockquote><blockquote><p>2小时前时间：12:10:15.666<br>30分钟前时间：13:40:15.666<br>500秒前时间：14:01:55.666</p></blockquote><hr><h2 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h2><p>LocalDateTime是一个不可变的日期-时间对象，它既包含了日期同时又含有时间，默认格式是yyyy-MM-ddTHH-mm-ss.zzz</p><h3 id="获取当前日期时间以及自定义日期时间"><a href="#获取当前日期时间以及自定义日期时间" class="headerlink" title="获取当前日期时间以及自定义日期时间"></a>获取当前日期时间以及自定义日期时间</h3><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取当前的日期时间</span>LocalDateTime localDateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前的日期时间："</span> <span class="token operator">+</span> localDateTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取自定义的的日期时间</span>LocalDateTime specifiedDateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义的日期时间："</span> <span class="token operator">+</span> specifiedDateTime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>当前的日期时间：2018-12-12T14:31:00.163<br>自定义的日期时间：2018-12-12T14:31:00.164</p></blockquote><h3 id="转化为日期和时间"><a href="#转化为日期和时间" class="headerlink" title="转化为日期和时间"></a>转化为日期和时间</h3><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//转化为LocalDate和LocalTime</span>LocalDate localDate <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">toLocalDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime localTime <span class="token operator">=</span> localDateTime<span class="token punctuation">.</span><span class="token function">toLocalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前日期："</span> <span class="token operator">+</span> localDate<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间："</span> <span class="token operator">+</span> localTime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行结果：</p><blockquote><p>当前日期：2018-12-12<br>当前时间：14:31:00.163</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8-stream</title>
      <link href="/2019/06/16/java8-stream/"/>
      <url>/2019/06/16/java8-stream/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-8中处理集合的优雅姿势——Stream"><a href="#Java-8中处理集合的优雅姿势——Stream" class="headerlink" title="Java 8中处理集合的优雅姿势——Stream"></a>Java 8中处理集合的优雅姿势——Stream</h1><p>在Java中，集合和数组是我们经常会用到的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但是在Java 8之前，集合和数组的处理并不是很便捷。</p><p>不过，这一问题在Java 8中得到了改善，Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。本文就来介绍下如何使用Stream。特别说明一下，关于Stream的性能及原理不是本文的重点，如果大家感兴趣后面会出文章单独介绍。</p><h2 id="Stream介绍"><a href="#Stream介绍" class="headerlink" title="Stream介绍"></a>Stream介绍</h2><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p><p>Stream有以下特性及优点：</p><ul><li>无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li>为函数式编程而生。对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li><li>惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><p>我们举一个例子，来看一下到底Stream可以做什么事情：</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/1.jpg" alt></p><p>￼上面的例子中，获取一些带颜色塑料球作为数据源，首先过滤掉红色的、把它们融化成随机的三角形。再过滤器并删除小的三角形。最后计算出剩余图形的周长。</p><p>如上图，对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作(terminal operation)。</p><h2 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h2><p>在Java 8中，可以有多种方法来创建流。</p><h3 id="1、通过已有的集合来创建流"><a href="#1、通过已有的集合来创建流" class="headerlink" title="1、通过已有的集合来创建流"></a>1、通过已有的集合来创建流</h3><p>在Java 8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了stream方法，可以将一个集合类转换成流。</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span> <span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上，通过一个已有的List创建一个流。除此以外，还有一个parallelStream方法，可以为集合创建一个并行流。</p><p>这种通过集合创建出一个Stream的方式也是比较常用的一种方式。</p><h3 id="2、通过Stream创建流"><a href="#2、通过Stream创建流" class="headerlink" title="2、通过Stream创建流"></a>2、通过Stream创建流</h3><p>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。</p><pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span> <span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如以上代码，直接通过of方法，创建并返回一个Stream。</p><h2 id="Stream中间操作"><a href="#Stream中间操作" class="headerlink" title="Stream中间操作"></a>Stream中间操作</h2><p>Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/2.jpg" alt></p><p>￼以下是常用的中间操作列表:</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/3.jpg" alt></p><p><strong>filter</strong></p><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤掉空字符串：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"H"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">!</span>string<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Hollis, , HollisChuang, H, hollis</span></code></pre><p><strong>map</strong></p><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> i <span class="token operator">-</span><span class="token operator">></span> i<span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//9,4,4,9,49,9,25</span></code></pre><p><strong>limit/skip</strong></p><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保理4个元素：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3,2,2,3</span></code></pre><p><strong>sorted</strong></p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法进行排序：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2,2,3,3,3,5,7</span></code></pre><p><strong>distinct</strong></p><p>distinct主要用来去重，以下代码片段使用 distinct 对元素进行去重：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3,2,7,5</span></code></pre><p>接下来我们通过一个例子和一张图，来演示下，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会发生什么。</p><p>代码如下：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span> <span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Stream s <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>过程及每一步得到的结果如下图：</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/4.jpg" alt></p><h2 id="Stream最终操作"><a href="#Stream最终操作" class="headerlink" title="Stream最终操作"></a>Stream最终操作</h2><p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就需要最终操作（terminal operation）</p><p>最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常：</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalStateException<span class="token operator">:</span> stream has already been operated upon or closed</code></pre><p>俗话说，“你永远不会两次踏入同一条河”也正是这个意思。</p><p>常用的最终操作如下图：</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/5.jpg" alt></p><p><strong>forEach</strong></p><p>Stream 提供了方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><pre class=" language-java"><code class="language-java">Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>random<span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>count</strong></p><p>count用来统计流中的元素个数。</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">,</span><span class="token string">"Hollis666"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span> <span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//7</span></code></pre><p><strong>collect</strong></p><p>collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">,</span> <span class="token string">"HollisChuang"</span><span class="token punctuation">,</span> <span class="token string">"hollis"</span><span class="token punctuation">,</span><span class="token string">"Hollis666"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span> <span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>strings  <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>string <span class="token operator">-</span><span class="token operator">></span> string<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"Hollis"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Hollis, HollisChuang, Hollis666, Hollis</span></code></pre><p>接下来，我们还是使用一张图，来演示下，前文的例子中，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会，在分别使用不同的最终操作可以得到怎样的结果：</p><p>下图，展示了文中介绍的所有操作的位置、输入、输出以及使用一个案例展示了其结果。</p><p><img src="http://cdn.cathetine.cn/blog/images/java8-stream/6.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Java 8中的Stream 的用途，优点等。还接受了Stream的几种用法，分别是Stream创建、中间操作和最终操作。</p><p>Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。</p><p>Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。</p><p>Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流装换成集合、以及元素的遍历等。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-design-pattern</title>
      <link href="/2019/06/15/spring-she-ji-mo-shi/"/>
      <url>/2019/06/15/spring-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈Spring中都用到了哪些设计模式"><a href="#谈谈Spring中都用到了哪些设计模式" class="headerlink" title="谈谈Spring中都用到了哪些设计模式?"></a>谈谈Spring中都用到了哪些设计模式?</h1><p><strong>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?</strong>这两个问题，在面试中比较常见。</p><p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p><h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p>Spring使用工厂模式可以通过 <font color="red"><strong>BeanFactory</strong></font> 或 <font color="red"><strong>ApplicationContext</strong></font> 创建 bean 对象。</p><p>两者对比：</p><ul><li><p><font color="red"><strong>BeanFactory</strong></font> ：延迟注入(使用到某个 bean 的时候才会注入),相比于BeanFactory来说会占用更少的内存，程序启动速度更快。</p></li><li><p><font color="red"><strong>ApplicationContext</strong></font> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</p></li></ul><p>ApplicationContext的三个实现类：</p><p><font color="red"><strong>ClassPathXmlApplication：</strong></font>把上下文文件当成类路径资源。</p><p><font color="red"><strong>FileSystemXmlApplication：</strong></font>从文件系统中的 XML 文件载入上下文定义信息。</p><p><font color="red"><strong>XmlWebApplicationContext：</strong></font>从Web系统中的XML文件载入上下文定义信息。</p><p>Example:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>support<span class="token punctuation">.</span>FileSystemXmlApplicationContext<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span>                <span class="token string">"C:/applicationcontext/src/main/resources/bean-factory-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HelloApplicationContext obj <span class="token operator">=</span> <span class="token punctuation">(</span>HelloApplicationContext<span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"helloApplicationContext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><font color="red"><strong>使用单例模式的好处:</strong></font></p><ul><li><p>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</p></li><li><p>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</p></li></ul><p><font color="red"><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong></font> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li><p><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</p></li><li><p><strong>request</strong> : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p></li><li><p><strong>session</strong> : 针对某个HTTP Session，Spring容器会根据bean id定义创建一个全新的bean实例， 且该bean仅在当前HTTP Session内有效。</p></li><li><p><strong>global-session</strong>： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p></li></ul><p><font color="red"><strong>Spring 实现单例的方式：</strong></font></p><ul><li>xml:<code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;&gt;</code></li></ul><ul><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p>Spring 通过 <font color="red">ConcurrentHashMap</font> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"'beanName' must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 检查缓存中是否存在实例  </span>            Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//...省略了很多代码</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//...省略了很多代码</span>                <span class="token comment" spellcheck="true">// 如果实例对象在不存在，我们注册到单例注册表中。</span>                <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> singletonObject <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//将对象添加到单例注册表</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> Object singletonObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">!=</span> null <span class="token operator">?</span> singletonObject <span class="token operator">:</span> NULL_OBJECT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><h4 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p><font color="red"><strong>Spring AOP</strong></font> 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="http://cdn.cathetine.cn/blog/images/spring-design-pattern/2.jpg" alt></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h4><p><font color="red"><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong></font>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><hr><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><p><img src="http://cdn.cathetine.cn/blog/images/spring-design-pattern/3.jpg" alt></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Template</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这是我们的模板方法</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">TemplateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">PrimitiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">PrimitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PrimitiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span>  <span class="token function">PrimitiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当前类实现</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//被子类实现的方法</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">PrimitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">PrimitiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateImpl</span> <span class="token keyword">extends</span> <span class="token class-name">Template</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PrimitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当前类实现</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PrimitiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当前类实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Spring 中 <font color="red"><strong>jdbcTemplate</strong></font>、<font color="red">**hibernateTemplate</font> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><hr><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><h4 id="Spring-事件驱动模型中的三种角色"><a href="#Spring-事件驱动模型中的三种角色" class="headerlink" title="Spring 事件驱动模型中的三种角色"></a>Spring 事件驱动模型中的三种角色</h4><h5 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h5><p><font color="red">ApplicationEvent</font> (<font color="red">org.springframework.context</font>包下)充当事件的角色,这是一个抽象类，它继承了<font color="red">java.util.EventObject</font>并实现了 <font color="red">java.io.Serializable</font>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <font color="red">ApplicationContextEvent</font> 的实现(继承自<font color="red">ApplicationContextEvent</font>)：</p><ul><li><p><font color="red">ContextStartedEvent</font>：<font color="red">ApplicationContext</font> 启动后触发的事件;</p></li><li><p><font color="red">ContextStoppedEvent</font>：<font color="red">ApplicationContext</font> 停止后触发的事件;</p></li><li><p><font color="red">ContextRefreshedEvent</font>：<font color="red">ApplicationContext</font> 初始化或刷新完成后触发的事件;</p></li><li><p><font color="red">ContextClosedEvent</font>：<font color="red">ApplicationContext</font> 关闭后触发的事件。</p></li></ul><p><img src="http://cdn.cathetine.cn/blog/images/spring-design-pattern/4.jpg" alt></p><h5 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h5><p><font color="red">ApplicationListener</font> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <font color="red">onApplicationEvent（）</font>方法来处理<font color="red">ApplicationEvent</font>。<font color="red">ApplicationListener</font>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了<font color="red"> ApplicationEvent</font>就可以了。所以，在 Spring中我们只要实现<font color="red"> ApplicationListener</font> 接口实现 <font color="red">onApplicationEvent()</font> 方法即可完成监听事件。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>EventListener<span class="token punctuation">;</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>E var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h5><p><font color="red">ApplicationEventPublisher</font> 充当了事件的发布者，它也是一个接口。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventPublisher</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><font color="red">ApplicationEventPublisher</font> 接口的<font color="red">publishEvent（）</font>这个方法在<font color="red">AbstractApplicationContext</font>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<font color="red">ApplicationEventMulticaster</font>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p><h5 id="Spring-的事件流程总结"><a href="#Spring-的事件流程总结" class="headerlink" title="Spring 的事件流程总结"></a>Spring 的事件流程总结</h5><ol><li><p>定义一个事件: 实现一个继承自 <font color="red">ApplicationEvent</font>，并且写相应的构造函数；</p></li><li><p>定义一个事件监听者：实现 <font color="red">ApplicationListener</font> 接口，重写 <font color="red">onApplicationEvent()</font> 方法；</p></li><li><p>使用事件发布者发布消息: 可以通过 <font color="red">ApplicationEventPublisher</font> 的 <font color="red">publishEvent()</font> 方法发布消息。</p></li></ol><p>Example:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DemoEvent</span><span class="token punctuation">(</span>Object source<span class="token punctuation">,</span>String message<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> message<span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>DemoEvent<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用onApplicationEvent接收消息</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>DemoEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String msg <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到的信息是："</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoPublisher</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    ApplicationContext applicationContext<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//发布事件</span>        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DemoEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当调用 <font color="red">DemoPublisher </font>的 <font color="red">publish()</font> 方法的时候，比如 <font color="red">demoPublisher.publish(“你好”)</font> ，控制台就会打印出:</p><blockquote><p>接收到的信息是：你好 。</p></blockquote><hr><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><h4 id="spring-AOP中的适配器模式"><a href="#spring-AOP中的适配器模式" class="headerlink" title="spring AOP中的适配器模式"></a>spring AOP中的适配器模式</h4><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<font color="red">AdvisorAdapter </font>。Advice 常用的类型有：</p><ul><li><font color="red">BeforeAdvice</font>（目标方法调用前,前置通知）</li><li><font color="red">AfterAdvice</font>（目标方法调用后,后置通知）</li><li><font color="red">AfterReturningAdvice</font>(目标方法执行结束后，return之前)</li><li>…..</li></ul><p>每个类型Advice（通知）都有对应的拦截器:</p><ul><li><font color="red">MethodBeforeAdviceInterceptor</font></li><li><font color="red">AfterReturningAdviceAdapter</font></li><li><font color="red">AfterReturningAdviceInterceptor</font>。</li></ul><p>Spring预定义的通知要通过对应的适配器，适配成 <font color="red">MethodInterceptor</font>接口(方法拦截器)类型的对象（如：<font color="red">MethodBeforeAdviceInterceptor</font> 负责适配 <font color="red">MethodBeforeAdvice</font>）。</p><h4 id="spring-MVC中的适配器模式"><a href="#spring-MVC中的适配器模式" class="headerlink" title="spring MVC中的适配器模式"></a>spring MVC中的适配器模式</h4><p>在Spring MVC中，<font color="red">DispatcherServlet</font> 根据请求信息调用 <font color="red">HandlerMapping</font>，解析请求对应的 <font color="red">Handler</font>。解析到对应的 <font color="red">Handler</font>（也就是我们平常说的<font color="red"> Controller</font> 控制器）后，开始由<font color="red">HandlerAdapter</font> 适配器处理。<font color="red">HandlerAdapter</font> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<font color="red">Controller</font> 作为需要适配的类。</p><p><font color="red">*<em>为什么要在 Spring MVC 中使用适配器模式？ *</em></font><br>Spring MVC 中的 <font color="red">Controller</font> 种类众多，不同类型的 <font color="red">Controller</font> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<font color="red">DispatcherServlet</font> 直接获取对应类型的<font color="red"> Controller</font>，需要的自行来判断，像下面这段代码一样：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">MultiActionController</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>MultiActionController<span class="token punctuation">)</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>xxx  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">XXX</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  </code></pre><p>假如我们再增加一个 <font color="red">Controller</font>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><hr><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <font color="red">InputStream</font>家族， <font color="red">InputStream</font> 类下有  <font color="red">FileInputStream </font>(读取文件)、 <font color="red">BufferedInputStream</font> (增加缓存,使读取文件速度大大提升)等子类都在不修改 <font color="red">InputStream</font> 代码的情况下扩展了它的功能。</p><p><img src="http://cdn.cathetine.cn/blog/images/spring-design-pattern/5.jpg" alt></p><p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <font color="red">Wrapper</font>或者 <font color="red">Decorator</font>。这些类基本上都是动态地给一个对象添加一些额外的职责。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring 框架中用到了哪些设计模式：</p><ul><li><p><font color="red"><strong>工厂设计模式</strong></font> : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p></li><li><p><font color="red"><strong>代理设计模式</strong></font> : Spring AOP 功能的实现。</p></li><li><p><font color="red"><strong>单例设计模式</strong></font> : Spring 中的 Bean 默认都是单例的。</p></li><li><p><font color="red"><strong>模板方法模式</strong></font> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p></li><li><p><font color="red"><strong>包装器设计模式</strong></font> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p></li><li><p><font color="red"><strong>观察者模式</strong></font>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</p></li><li><p><font color="red"><strong>适配器模式</strong></font> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTree和B+Tree</title>
      <link href="/2019/06/14/btree-he-b-tree/"/>
      <url>/2019/06/14/btree-he-b-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="B树和B-树原理及索引应用"><a href="#B树和B-树原理及索引应用" class="headerlink" title="B树和B+树原理及索引应用"></a>B树和B+树原理及索引应用</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="grey">B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在讲B+树之前必须先了解<strong>二叉查找树</strong>、<strong>平衡二叉树（AVLTree）</strong>和<strong>平衡多路查找树（B-Tree）</strong>，B+树即由这些树逐步优化而来。</font></p><hr><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br>如下图所示就是一棵二叉查找树，</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/1.jpg" alt></p><p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p><p>二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/2.jpg" alt></p><p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。</p><hr><h3 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h3><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/3.jpg" alt></p><p>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下：</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/4.jpg" alt></p><p>这四种失去平衡的姿态都有各自的定义：</p><ul><li><p><strong>LL</strong>：LeftLeft，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</p></li><li><p><strong>RR</strong>：RightRight，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</p></li><li><p><strong>LR</strong>：LeftRight，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</p></li><li><p><strong>RL</strong>：RightLeft，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</p></li></ul><p>AVL树失去平衡之后，可以通过旋转使其恢复平衡。下面分别介绍四种失去平衡的情况下对应的旋转方法。</p><p><strong>LL的旋转：</strong>LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：</p><ol><li>将根节点的左孩子作为新根节点。</li><li>将新根节点的右孩子作为原根节点的左孩子。</li><li>将原根节点作为新根节点的右孩子。</li></ol><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/5.jpg" alt></p><p><strong>RR的旋转：</strong>RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：</p><ol><li>将根节点的右孩子作为新根节点。</li><li>将新根节点的左孩子作为原根节点的右孩子。</li><li>将原根节点作为新根节点的左孩子。</li></ol><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/6.jpg" alt></p><p><strong>LR的旋转</strong>：LR失去平衡的情况下，需要进行两次旋转，步骤如下：</p><ol><li>围绕根节点的左孩子进行RR旋转。</li><li>围绕根节点进行LL旋转。</li></ol><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/7.jpg" alt></p><p><strong>RL的旋转：</strong>RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：</p><ol><li>围绕根节点的右孩子进行LL旋转。</li><li>围绕根节点进行RR旋转。</li></ol><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/8.jpg" alt></p><hr><h3 id="平衡多路查找树（B-Tree）"><a href="#平衡多路查找树（B-Tree）" class="headerlink" title="平衡多路查找树（B-Tree）"></a>平衡多路查找树（B-Tree）</h3><p>B-Tree是为磁盘等外存储设备设计的一种<strong>平衡查找树</strong>。因此在讲B-Tree之前先了解下磁盘的相关知识。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：</p><blockquote><p>mysql&gt; show variables like ‘innodb_page_size’;1</p></blockquote><p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p><strong>一棵m阶的B-Tree有如下特性：</strong></p><ol><li>每个节点最多有m个孩子。</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li><li>ki(i=1,…n)为关键字，且关键字升序排序。</li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p><strong>B-Tree</strong>中的<strong>每个节点</strong>根据实际情况可以包含<strong>大量的关键字信息</strong>和<strong>分支</strong><br>如下图所示为一个<strong><font color="red">3阶</font></strong>的B-Tree：</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/9.jpg" alt></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><hr><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p><strong>B+Tree相对于B-Tree有几点不同：</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="http://cdn.cathetine.cn/blog/images/b-treeAndb+tree/10.jpg" alt></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>数据库中的B+Tree索引可以分为<strong>聚集索引（clustered index）</strong>和<strong>辅助索引（secondary index）</strong>。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-tree面试题</title>
      <link href="/2019/06/13/b-tree-mian-shi-ti/"/>
      <url>/2019/06/13/b-tree-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="B树，B-树，红黑树，数据库常见面试题"><a href="#B树，B-树，红黑树，数据库常见面试题" class="headerlink" title="B树，B+树，红黑树，数据库常见面试题"></a>B树，B+树，红黑树，数据库常见面试题</h1><h3 id="1-数据库索引有哪些，优缺点？"><a href="#1-数据库索引有哪些，优缺点？" class="headerlink" title="1. 数据库索引有哪些，优缺点？"></a>1. 数据库索引有哪些，优缺点？</h3><ul><li>hash索引和B+树索引</li><li>hash索引等值查询效率高，但是不能排序，因此不能进行范围查询</li><li>B+树索引数据有序，能够进行范围查询</li></ul><h3 id="2-为什么不用二叉查找树作为数据库索引？"><a href="#2-为什么不用二叉查找树作为数据库索引？" class="headerlink" title="2. 为什么不用二叉查找树作为数据库索引？"></a>2. 为什么不用二叉查找树作为数据库索引？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树，查找到指定数据，效率其实很高logn。但是数据库索引文件有可能很大，关系型数据存储了上亿条数据，索引文件大则上G，不可能全部放入内存中，而是需要的时候换入内存，方式是磁盘页。一般来说树的一个节点就是一个磁盘页。如果使用二叉查找树，那么每个节点存储一个元素，查找到指定元素，需要进行大量的磁盘IO，效率很低。<br>而B树解决了这个问题，通过单一节点包含多个data，大大降低了树的高度，大大减少了磁盘IO次数。</p><h3 id="3-B树和二叉查找树的性能对比？"><a href="#3-B树和二叉查找树的性能对比？" class="headerlink" title="3. B树和二叉查找树的性能对比？"></a>3. B树和二叉查找树的性能对比？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B树包括B+树的设计思想都是尽可能的降低树的高度，以此降低磁盘IO的次数，因为一个索引节点就表示一个磁盘页，页的换入换出次数越多，表示磁盘IO次数越多，越低效。<br>B树算法减少定位数据所在的节点时所经历的磁盘IO次数，从而加快存取速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据。（根节点100值，第二层可以存储99个节点（k-1），也就是99100个值，第三层可以存储（99<em>100-1）</em>100）结果是近似100万个数据。而如果使用二叉查找树，则需要将近20层，也就是进行20次磁盘IO，性能差距如此之大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）。</p><h3 id="4-B-对比B树的优点？"><a href="#4-B-对比B树的优点？" class="headerlink" title="4. B+对比B树的优点？"></a>4. B+对比B树的优点？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为B树的每个节点除了存储指向子节点的索引之外，还有data域，因此单一节点存储的指向子节点的索引并不是很多，树高度较高，磁盘IO次数较多，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而B+树单一节点存储的指向子节点的索引更多，B+树空间利用率高，因此B+树高度更低，磁盘IO次数更少，性能更好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为B树的中间节点存储了数据，所以整个树的每一层都有可能查找到要查找的数据，查询性能不稳定，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而B+树所有的data都存储在叶子节点，且叶子节点位于同一层，因此查询性能稳定。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B树如果想要进行范围查找，需要频繁的进行二叉树的中序遍历，进行范围查找比较复杂，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>B+树要查找的元素都位于叶子节点，且连接形成有序链表，便于范围查找。</strong></p><h3 id="5-B树，B-树使用场景。"><a href="#5-B树，B-树使用场景。" class="headerlink" title="5. B树，B+树使用场景。"></a>5. B树，B+树使用场景。</h3><h4 id="B树的应用"><a href="#B树的应用" class="headerlink" title="B树的应用"></a>B树的应用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B树大量应用在数据库和文件系统当中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）</p><h4 id="B-树的应用"><a href="#B-树的应用" class="headerlink" title="B+树的应用"></a>B+树的应用</h4><p>mysql使用<strong>B+树</strong>作为索引,B+树相对B树的优点：</p><ol><li>B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。</li><li>IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。</li></ol><p><font color="green"><strong>1.MYISAM</strong></font></p><p><img src="http://cdn.cathetine.cn/blog/images/b-tree/1.jpg" alt></p><p><font color="green"><strong>2. INNODB</strong></font></p><p><img src="http://cdn.cathetine.cn/blog/images/b-tree/2.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB索引和MyISAM最大的区别是它只有一个数据文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点数据域保存了完整的数据记录。所以我们又把它的主索引叫做聚集索引。而它的辅助索引和MyISAM也会有所不同，它的辅助索引都是将主键作为数据域。所以，这样当我们查找的时候通过辅助索引要先找到主键，然后通过主索引再找到对于的主键，得到信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyISAM表索引在处理文本索引时更具优势，而INNODB表索引在其它类型上更具效率优势，同时MySQL高并发需要事务场景时，只能使用INNODB表。</p><h3 id="6-为什么数据库索引不用红黑树而用B-树？"><a href="#6-为什么数据库索引不用红黑树而用B-树？" class="headerlink" title="6. 为什么数据库索引不用红黑树而用B+树？"></a>6. 为什么数据库索引不用红黑树而用B+树？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红黑树当插入删除元素的时候会进行频繁的变色与旋转（左旋，右旋），来保证红黑树的性质，浪费时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是当数据量较小，数据完全可以放入内存中，不需要进行磁盘IO，这时候，红黑树时间复杂度比B+树低。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如TreeSet TreeMap 和HashMap （jdk1.8）就是使用红黑树作为底层数据结构，以及linux中进程的调度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用指令</title>
      <link href="/2019/06/12/linux-chang-yong-zhi-ling/"/>
      <url>/2019/06/12/linux-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h1><h2 id="一、日常使用命令-常用快捷键命令"><a href="#一、日常使用命令-常用快捷键命令" class="headerlink" title="一、日常使用命令/常用快捷键命令"></a>一、日常使用命令/常用快捷键命令</h2><h3 id="开关机命令"><a href="#开关机命令" class="headerlink" title="开关机命令"></a>开关机命令</h3><ul><li><p>shutdown –h now：立刻进行关机</p></li><li><p>shutdown –r now：现在重新启动计算机</p></li><li><p>reboot：现在重新启动计算机</p></li><li><p>su -：切换用户；passwd：修改用户密码</p></li><li><p>logout：用户注销</p></li></ul><h3 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h3><ul><li><p>tab = 补全</p></li><li><p>ctrl + l -：清屏，类似clear命令</p></li><li><p>ctrl + r -：查找历史命令（history）；ctrl+c = 终止</p></li><li><p>ctrl+k = 删除此处至末尾所有内容</p></li><li><p>ctrl+u = 删除此处至开始所有内容</p></li></ul><h2 id="二、系统信息监控-查看"><a href="#二、系统信息监控-查看" class="headerlink" title="二、系统信息监控/查看"></a>二、系统信息监控/查看</h2><ul><li><p>ps 是Process Status的缩写，ps命令用来列出系统中当前运行的那些进程的快照。</p><ul><li>-a 显示同一终端下的所有程序</li><li>-A 显示所有进程</li><li>-e 等于“-A”</li><li>-f  显示程序间的关系,pid &amp; ppid</li><li>-H 显示树状结构</li><li>-u  指定(当前)用户的所有进程</li><li>示例<ul><li>ps -ef</li><li>ps -aux</li></ul></li></ul></li><li><p>top 性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器</p></li></ul><ul><li>netstat 查看访问网络连接状态<ul><li>-a或–all 显示所有连线中的Socket</li><li>-n或–numeric 直接使用IP地址，而不通过域名服务器</li><li>-p或–programs 显示正在使用Socket的程序识别码和程序名称</li><li>-t或–tcp 显示TCP传输协议的连线状况</li><li>-u或–udp 显示UDP传输协议的连线状况</li><li>示例<ul><li>netstat -apn | grep 8080</li><li>netstat -apnt | grep 8080</li></ul></li></ul></li></ul><h2 id="三、编辑器"><a href="#三、编辑器" class="headerlink" title="三、编辑器"></a>三、编辑器</h2><ul><li>vi 编辑器常用命令<ul><li>编辑 </li><li>查看<ul><li>/word</li><li>查找上一个 n</li><li>查找下一个 N</li></ul></li><li>替换<ul><li>xxx</li></ul></li><li>撤回、重做 u、ctrl + r</li><li>添加行<ul><li>上一行 O</li><li>下一行 o</li></ul></li><li>翻页 ctrl + d, ctrl + u</li><li>显示行号 :set nu</li><li>显示当前行信息 ctrl + g</li><li>行<ul><li>首 0</li><li>尾 $</li><li>第一行 gg</li><li>最后一行 G</li></ul></li><li>句<ul><li>首 (</li><li>尾 )</li><li>段</li><li>首 {</li><li>尾 }</li></ul></li><li>屏幕<ul><li>上滚 ctrl + v</li><li>下滚 ctrl + e</li><li>上半屏 ctrl + u</li><li>下半屏 ctrl + d</li><li>上滚整屏 ctrl + b</li><li>下滚整屏 ctrl + f</li></ul></li><li>保存退出<ul><li>w 保存</li><li>q 退出</li><li>q! 不保存，强制退出</li></ul></li></ul></li></ul><h2 id="四、磁盘文件有关"><a href="#四、磁盘文件有关" class="headerlink" title="四、磁盘文件有关"></a>四、磁盘文件有关</h2><ul><li>df 检查linux服务器的文件系统的磁盘空间占用情况<ul><li>-T 文件系统类型</li><li>-h 方便阅读方式显示，1K=1024</li><li>-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024</li><li>-l 只显示本地文件系统列表</li><li>-k 区块为1024字节</li><li>-a 全部文件系统列表</li><li>示例<ul><li>df -hl 查看当前目录下所有目录、文件的大小</li></ul></li></ul></li></ul><ul><li>du 查看文件和目录磁盘使用的空间<ul><li>-a 显示当前目录以及子目录下所有的文件大小</li><li>-h 自动转换单位 M,GB</li><li>-s 统计总大小</li><li>示例<ul><li>du -a</li><li>du -sh 当前目录大小</li></ul></li></ul></li></ul><ul><li>find 查找文件，配合正则使用更佳<ul><li>-name 名字</li><li>-size 大小</li><li>-type 类型</li><li>示例</li><li>find /home/server -name server.xml 查找/home/server下名字为server.xml的文件</li><li>find . -type d | sort 查找当前所有目录并排序</li><li>find . -size +1000c -print 查找当前目录大于1K的文件</li></ul></li></ul><ul><li>tail 从指定点开始将文件写到标准输出<ul><li>示例</li><li>tail -20f app.log</li></ul></li></ul><ul><li>tar 打包工具<ul><li>-c 新建压缩文件，与 x 逆操作</li><li>-v 显示操作过程</li><li>-f 指定压缩文件</li><li>-x 解压缩文件 与 c 反向操作</li><li>-z 支持gzip解压文件</li><li>示例<ul><li>tar -xvf name.tar.gz 解包</li><li>tar -cvf name.tar.gz /dir 打包，未压缩</li><li>tar -zxvf name.tar.gz 解包,gzip解压缩</li><li>tar -zcvf name.tar.gz /dir 打包，gzip压缩</li></ul></li></ul></li></ul><ul><li>grep 文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行信息打印出来。<ul><li>-A 前多少行，不包括当前行</li><li>-B 后多少行，不包括当前行</li><li>-C 前后多少行，不包括当前行</li><li>-c 统计行数</li><li>-i 忽略大小写</li><li>示例<ul><li>grep -C 10 keywords fileName.log 在文件fileName.log查找关键词keywords前后10行</li></ul></li></ul></li></ul><ul><li>wc 是 Word Count 缩写，统计指定文件中的字节数、字数、行数，并将统计结果显示输出<ul><li>-c 统计字节数</li><li>-l 统计行数</li><li>-m 统计字符数。这个标志不能与 -c 标志一起使用</li><li>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串</li><li>-L 打印最长行的长度</li><li>示例<ul><li>wc -m</li></ul></li></ul></li></ul><ul><li>xargs 替换工具，读取输入数据重新格式化后输出。简单的理解就是通过指定的分隔符(默认空格)切割(split)字符串,然后把处理后的多列数据作为参数，作为下一个指令的参数传入。<ul><li>-a 即–arg-file=FILE 从指定文件读取内容</li><li>-d 即–delimiter=CHARACTER 指定分隔符，默认空格</li><li>-n 多行显示，指定一行显示的列数</li><li>示例<ul><li>echo ‘–help’ | xargs cat 即cat –help</li><li>jps | awk ‘{print $1}’ | xargs kill -9 关闭所有Java进程</li></ul></li></ul></li></ul><h2 id="五、用户相关操作"><a href="#五、用户相关操作" class="headerlink" title="五、用户相关操作"></a>五、用户相关操作</h2><ul><li>su - 或 su - root 切换到root用户</li></ul><ul><li>exit 退回到上一个用户</li></ul><ul><li>whoami 查看当前用户</li></ul><ul><li>useradd 添加用户，所有用户在配置文件：/etc/passwd<ul><li>-g 组别编号，缺省时表当前用户组</li><li>-u 用户编号</li><li>-d 家目录，默认在/home</li><li>示例<ul><li>useradd -g 666 -u 666 -d /home/Aron Aron 新建Aron用户</li></ul></li></ul></li></ul><ul><li>user modify 修改用户<ul><li>-g 组编号</li><li>-u 用户编号</li><li>-d 家目录</li><li>-l 新名字</li><li>示例<ul><li>usermod -g 666 -u 666 -d /home/Aron -l Aron2 Aron 注意修改家目录时需要手动创建</li></ul></li></ul></li></ul><ul><li>userdel删除用户<ul><li>-r 删除用户同时删除其家目录</li><li>示例<ul><li>userdel Aron</li><li>userdel -r Aron 删除用户同时删除其家目录</li></ul></li></ul></li></ul><ul><li>设置用户密码<ul><li>示例<ul><li>passwd Aron</li></ul></li></ul></li></ul><ul><li>chmod 即change mode,改变文件模式。<ul><li>语法chmod [-cfvR] [–help] [–version] mode file…，其中，mode是权限设定字串，格式为[ugoa…][[+-=][rwxX]…][,…],说明:ugoa 中的u为当前用户，g当前用户组，o其他用户组，a所有用户</li><li>-c 若该文件权限确实已经更改，才显示其更改动作</li><li>-f 若该文件权限无法被更改也不要显示错误讯息</li><li>-v 显示权限变更的详细资料</li><li>-R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>示例<ul><li>chmod ugo+r file1.txt 将文件file1.txt设置为所有人可读</li><li>chmod u+r,g+w,o+r file1.txt将文件file1.txt设置为当前用户可读，同组可写，其他组可读</li><li>chmod -R a+rw /home/server 将目录/home/server以递归形式设置为所有人可读写</li></ul></li></ul></li></ul><ul><li>chgrp 即change group改变用户组，语法chgrp [-R] newGroup fileOrDirector<ul><li>-R 递归方式查找子目录</li><li>示例<ul><li>chgrp Aron app.java</li><li>chgrp -R Aron /data</li></ul></li></ul></li></ul><ul><li>chown 即change owner改变拥有者<ul><li>只改拥有者，语法chown [-R] newUser fileOrDirector</li><li>修改拥有者，同时修改用户组，语法 chown [-R] newUser:newGroup fileOrDirector</li><li>示例<ul><li>chown Aron app.java<br>chown Aron:AronGroup app.java</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/06/12/jmm-yuan-li/"/>
      <url>/2019/06/12/jmm-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="java面试知识点解析–java内存模型"><a href="#java面试知识点解析–java内存模型" class="headerlink" title="java面试知识点解析–java内存模型"></a>java面试知识点解析–java内存模型</h1><h3 id="1-JMM的介绍"><a href="#1-JMM的介绍" class="headerlink" title="1. JMM的介绍"></a>1. JMM的介绍</h3><p>在&lt;&lt;深入理解Java虚拟机&gt;&gt;中看到的定义。原文如下：<br>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p><p>关于定义的理解这是一个仁者见仁智者见智的事情。出现线程安全的问题一般是因为<strong>主内存和工作内存数据不一致性</strong>和<strong>重排序</strong>导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，那么，理解它们的核心在于理解java内存模型（JMM）。</p><p>在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到<strong>多个线程间相互通信告知彼此的状态以及当前的执行结果</strong>等，另外，为了性能优化，还会涉及到<strong>编译器指令重排序和处理器指令重排序</strong>。下面会一一来聊聊这些知识。</p><hr><h3 id="2-内存模型抽象结构"><a href="#2-内存模型抽象结构" class="headerlink" title="2. 内存模型抽象结构"></a>2. 内存模型抽象结构</h3><p>在并发编程中主要需要解决两个问题：</p><p><strong>1. 线程之间如何通信;</strong></p><p><strong>2. 线程之间如何完成同步</strong>（这里的线程指的是并发执行的活动实体）。</p><p>通信是指线程之间以何种机制来交换信息，主要有两种：<font color="red">共享内存</font>和<font color="red">消息传递</font>。这里，可以分别类比上面的两个举例。java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量来完成隐式通信。如果程序员不能理解Java的共享内存模型在编写并发程序时一定会遇到各种各样关于内存可见性的问题。</p><blockquote><p><font color="green"><strong>哪些是共享变量</strong></font></p></blockquote><p>在java程序中所有<strong>实例域</strong>，<strong>静态域</strong>和<strong>数组元素</strong>都是放在堆内存中（所有线程均可访问到，是可以共享的），而局部变量，方法定义参数和异常处理器参数不会在线程间共享。共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。关于JVM运行时内存区域在后面的文章会讲到。</p><blockquote><p><font color="green"><strong>2.JMM抽象结构模型</strong></font></p></blockquote><p>我们知道CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。</p><p><img src="http://cdn.cathetine.cn/blog/images/JMM/1.jpg" alt></p><p>如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：</p><ul><li><p>线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；</p></li><li><p>线程B从主存中读取最新的共享变量</p></li></ul><p>从横向去看看，线程A和线程B就好像通过共享变量在进行隐式通信。这其中有很有意思的问题，如果线程A更新后数据并没有及时写回到主存，而此时线程B读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主存，从而对每个线程都是可见的。</p><hr><h3 id="3-重排序"><a href="#3-重排序" class="headerlink" title="3. 重排序"></a>3. 重排序</h3><p>一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，<strong>为了提高性能，编译器和处理器常常会对指令进行重排序。</strong>一般重排序可以分为如下三种：</p><p><img src="http://cdn.cathetine.cn/blog/images/JMM/2.jpg" alt></p><p align="center" style="color:grey">*从源码到最终执行的指令序列的示意图*</p>1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。<p>如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是DCL问题，这个在以后的文章中会具体去聊。<strong>针对编译器重排序</strong>，JMM的编译器重排序规则会<strong>禁止一些特定类型的编译器重排序</strong>；针对<strong>处理器重排序，</strong>编译器在生成指令序列的时候会<strong>通过插入内存屏障指令来禁止某些特殊的处理器重排序</strong>。</p><p>那么什么情况下，不能进行重排序了？下面就来说说数据依赖性。有如下代码：</p><blockquote><p>double pi = 3.14 //A</p></blockquote><blockquote><p>double r = 1.0 //B</p></blockquote><blockquote><p>double area = pi * r * r //C</p></blockquote><p>这是一个计算圆面积的代码，由于A,B之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是A-&gt;B-&gt;C或者B-&gt;A-&gt;C执行最终结果都是3.14，即A和B之间没有数据依赖性。具体的定义为：如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性这里就存在三种情况：1. 读后写；2.写后写；3. 写后读，者三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。<strong>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序</strong></p><p>另外，还有一个比较有意思的就是as-if-serial语义。</p><blockquote><p><strong>as-if-serial</strong></p></blockquote><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。as-if-serial语义把单线程程序保护了起来，<strong>遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。</strong>比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上A,B两行不存在数据依赖性可能会进行重排序，即A，B不是顺序执行的。as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。</p><hr><h3 id="4-happens-before规则"><a href="#4-happens-before规则" class="headerlink" title="4. happens-before规则"></a>4. happens-before规则</h3><p>上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。下面以两个方面来说。</p><h4 id="4-1-happens-before定义"><a href="#4-1-happens-before定义" class="headerlink" title="4.1 happens-before定义"></a>4.1 happens-before定义</h4><p>happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出，有兴趣的可以google一下。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，J<strong>MM可以通过happens-before关系向程序员提供跨线程的内存可见性保证</strong>（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：</p><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><p>2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p><p>上面的<strong>1）是JMM对程序员的承诺</strong>。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！</p><p>上面的<strong>2）是JMM对编译器和处理器重排序的约束原则</strong>。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。</p><p>下面来比较一下as-if-serial和happens-before:</p><blockquote><p><strong>as-if-serial VS happens-before</strong></p></blockquote><ol><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ol><h4 id="4-2-具体规则"><a href="#4-2-具体规则" class="headerlink" title="4.2 具体规则"></a>4.2 具体规则</h4><p>具体的一共有六项规则：</p><ol><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li><li>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li></ol><p><strong>下面以一个具体的例子来讲下如何使用这些规则进行推论：</strong></p><p>依旧以上面计算圆面积的进行描述。利用程序顺序规则（规则1）存在三个happens-before关系：1. A happens-before B；2. B happens-before C;3. A happens-before C。这里的第三个关系是利用传递性进行推论的。A happens-before B,定义1要求A执行结果对B可见，并且A操作的执行顺序在B操作之前，但与此同时利用定义中的第二条，A,B操作彼此不存在数据依赖性，两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许A，B两个操作重排序，即happens-before关系并不代表了最终的执行顺序。</p><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>上面已经聊了关于JMM的两个方面：</p><ol><li>JMM的抽象结构（主内存和线程工作内存）；</li><li>重排序以及happens-before规则。</li></ol><p>接下来，我们来做一个总结:</p><ol><li>如果让我们设计JMM应该从哪些方面考虑，也就是说JMM承担哪些功能；</li><li>happens-before与JMM的关系；</li><li>由于JMM，多线程情况下可能会出现哪些问题？</li></ol><h4 id="5-1-JMM的设计"><a href="#5-1-JMM的设计" class="headerlink" title="5.1 JMM的设计"></a>5.1 JMM的设计</h4><p><img src="http://cdn.cathetine.cn/blog/images/JMM/3.jpg" alt></p><p align="center" style="color:grey">*JMM层级图*</p>JMM是语言级的内存模型，在我的理解中JMM处于中间层，包含了两个方面：**（1）内存模型；（2）重排序以及happens-before规则。**同时，为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制。而上层会有基于JMM的关键字和J.U.C包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程。站在JMM设计者的角度，在设计JMM时需要考虑两个关键因素:<p><strong>1.程序员对内存模型的使用</strong><br>程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。</p><p><strong>2.编译器和处理器对内存模型的实现</strong><br>编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</p><p>另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：</p><ol><li>会改变程序执行结果的重排序。</li><li>不会改变程序执行结果的重排序。</li></ol><p>JMM对这两种不同性质的重排序，采取了不同的策略，如下。</p><ol><li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种</li><li>重排序）</li></ol><p>JMM的设计图为：</p><p><img src="http://cdn.cathetine.cn/blog/images/JMM/4.jpg" alt></p><p align="center" style="color:grey">*JMM设计示意图*</p>从图可以看出：<ol><li><p>JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B）。</p></li><li><p>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</p></li></ol><h4 id="5-2-happens-before与JMM的关系"><a href="#5-2-happens-before与JMM的关系" class="headerlink" title="5.2 happens-before与JMM的关系"></a>5.2 happens-before与JMM的关系</h4><p><img src="http://cdn.cathetine.cn/blog/images/JMM/5.jpg" alt></p><p align="center" style="color:grey">*happens-before与JMM的关系*</p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法<h4 id="5-3-今后可能需要关注的问题"><a href="#5-3-今后可能需要关注的问题" class="headerlink" title="5.3 今后可能需要关注的问题"></a>5.3 今后可能需要关注的问题</h4><p>从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是<strong>数据可见性</strong>的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是DCL（双重检验锁），这就是需要禁<strong>止重排序</strong>，另外，在多线程下原子操作例如i++不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从<strong>原子性</strong>，<strong>有序性</strong>，<strong>可见性</strong>三个方面进行考虑。J.U.C包下的并发工具类和并发容器也是需要花时间去掌握的，这些东西在以后得文章中多会一一进行讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile原理</title>
      <link href="/2019/06/11/volatile-yuan-li/"/>
      <url>/2019/06/11/volatile-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面试知识点解析——volatile原理"><a href="#Java-面试知识点解析——volatile原理" class="headerlink" title="Java 面试知识点解析——volatile原理"></a>Java 面试知识点解析——volatile原理</h1><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><hr><h3 id="二、并发编程的3个基本概念"><a href="#二、并发编程的3个基本概念" class="headerlink" title="二、并发编程的3个基本概念"></a>二、并发编程的3个基本概念</h3><p><strong>（1）原子性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义： <font color="red">即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. 基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. 所有引用reference的赋值操作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c. java.concurrent.Atomic.* 包中所有类的一切操作</p><p><strong>（2）可见性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义：<font color="red">指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p><strong>(3）有序性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义：<font color="red">即程序执行的顺序按照代码的先后顺序执行。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。</strong>前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><hr><h3 id="三、锁的互斥和可见性"><a href="#三、锁的互斥和可见性" class="headerlink" title="三、锁的互斥和可见性"></a>三、锁的互斥和可见性</h3><p>锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。<br>（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。<br>（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即<strong>当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。</strong>如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.对变量的写操作不依赖于当前值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.该变量没有包含在具有其他变量的不变式中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这些条件表明，可以被写入volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><hr><h3 id="四、Java的内存模型JMM以及共享变量的可见性"><a href="#四、Java的内存模型JMM以及共享变量的可见性" class="headerlink" title="四、Java的内存模型JMM以及共享变量的可见性"></a>四、Java的内存模型JMM以及共享变量的可见性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/1.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。</font></p><hr><h3 id="五、volatile变量的特性"><a href="#五、volatile变量的特性" class="headerlink" title="五、volatile变量的特性"></a>五、volatile变量的特性</h3><p>  <strong>（1）保证可见性，不保证原子性</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.这个写会操作会导致其他线程中的缓存无效。</p><p>   <strong>（2）禁止指令重排</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>a.重排序操作不会对存在数据依赖关系的操作进行重排序。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>b.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><p><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/2.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>b.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。</font></p><hr><h3 id="六、volatile不适用的场景"><a href="#六、volatile不适用的场景" class="headerlink" title="六、volatile不适用的场景"></a>六、volatile不适用的场景</h3><p>（1）volatile不适合复合操作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，inc++不是一个原子性操作，可以由读取、加、赋值3步组成，所以结果并不能达到30000。<br><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/3.png" alt><br>（2）解决方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.采用synchronized<br><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/4.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.采用Lock<br><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/5.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.采用java并发包中的原子操作类，原子操作类是通过CAS循环的方式来保证其原子性的<br><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/6.png" alt></p><hr><h3 id="七、volatile原理"><a href="#七、volatile原理" class="headerlink" title="七、volatile原理"></a>七、volatile原理</h3><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“<font color="red">内存屏障</font>”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br><strong>I. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</strong><br><strong>II. 它会强制将对缓存的修改操作立即写入主存；</strong><br><strong>III. 如果是写操作，它会导致其他CPU中对应的缓存行无效。</strong></p><hr><h3 id="八、单例模式的双重锁为什么要加volatile"><a href="#八、单例模式的双重锁为什么要加volatile" class="headerlink" title="八、单例模式的双重锁为什么要加volatile"></a>八、单例模式的双重锁为什么要加volatile</h3><p><img src="http://cdn.cathetine.cn/blog/images/volatile-yuan-li/7.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance = new TestInstance();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以分解为3行伪代码:</p><blockquote><p>1.memory = allocate()   //分配内存<br>2.ctorInstanc(memory)   //初始化对象<br>3.instance = memory  //设置instance指向刚分配的地址</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码在编译运行时，可能会出现重排序从1-2-3排序为1-3-2。在多线程的情况下会出现以下问题。线程A在执行第5行代码时，B线程进来，而此时A执行了1和3，没有执行2，此时B线程判断instance不为null，直接返回一个未初始化的对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/06/10/ji-suan-ji-wang-luo/"/>
      <url>/2019/06/10/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面试知识点解析——网络协议篇"><a href="#Java-面试知识点解析——网络协议篇" class="headerlink" title="Java 面试知识点解析——网络协议篇"></a>Java 面试知识点解析——网络协议篇</h1><h3 id="（一）网络基础知识"><a href="#（一）网络基础知识" class="headerlink" title="（一）网络基础知识"></a>（一）网络基础知识</h3><hr><h4 id="1）Http和Https的区别？"><a href="#1）Http和Https的区别？" class="headerlink" title="1）Http和Https的区别？"></a>1）Http和Https的区别？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p><ul><li>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</li><li>开销：Https通信需要证书，而证书一般需要向认证机构购买；</li></ul><hr><h4 id="2）对称加密与非对称加密"><a href="#2）对称加密与非对称加密" class="headerlink" title="2）对称加密与非对称加密"></a>2）对称加密与非对称加密</h4><p>答：<br>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><hr><h4 id="3）三次握手与四次挥手"><a href="#3）三次握手与四次挥手" class="headerlink" title="3）三次握手与四次挥手"></a>3）三次握手与四次挥手</h4><p>答：<br><strong>(1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功）</strong></p><ul><li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p></li><li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p></li><li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p></li></ul><p><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/1.png" alt></p><p><strong>(2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）：</strong></p><ul><li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p></li><li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p></li><li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></li></ul><p><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/2.png" alt></p><p><strong>(3). 通俗一点的理解就是：</strong><br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/3.png" alt></p><hr><h4 id="4）为什么-TCP-链接需要三次握手，两次不可以么？"><a href="#4）为什么-TCP-链接需要三次握手，两次不可以么？" class="headerlink" title="4）为什么 TCP 链接需要三次握手，两次不可以么？"></a>4）为什么 TCP 链接需要三次握手，两次不可以么？</h4><p>答：“三次握手” 的目的是为了<strong>防止已失效的链接请求报文</strong>突然又传送到了服务端，因而产生错误。</p><ul><li><p>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</p></li><li><p>现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</p></li></ul><p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p><hr><h4 id="5）为什么要四次挥手？"><a href="#5）为什么要四次挥手？" class="headerlink" title="5）为什么要四次挥手？"></a>5）为什么要四次挥手？</h4><p>答：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p><p>所以想要愉快的结束这次对话就需要四次挥手。</p><hr><h4 id="6）TCP-协议如何来保证传输的可靠性"><a href="#6）TCP-协议如何来保证传输的可靠性" class="headerlink" title="6）TCP 协议如何来保证传输的可靠性"></a>6）TCP 协议如何来保证传输的可靠性</h4><p>答：TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</p><p><strong>对于可靠性，TCP通过以下方式进行保证：</strong></p><ul><li><p><strong>数据包校验：</strong>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p></li><li><p><strong>对失序数据包重排序：</strong>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p></li><li><p><strong>丢弃重复数据：</strong>对于重复数据，能够丢弃重复数据；</p></li><li><p><strong>应答机制：</strong>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p></li><li><p><strong>超时重发：</strong>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p></li><li><p><strong>流量控制：</strong>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p></li></ul><hr><h4 id="7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h4><p>答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p><p><strong>(1). DDos 攻击：</strong></p><ul><li>客户端向服务端发送请求链接数据包</li><li>服务端向客户端发送确认数据包</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li></ul><p><strong>(2). DDos 预防：</strong>（没有彻底根治的办法，除非不使用TCP）</p><ul><li>限制同时打开SYN半链接的数目</li><li>缩短SYN半链接的Time out 时间</li><li>关闭不必要的服务</li></ul><hr><h4 id="8）GET-与-POST-的区别？"><a href="#8）GET-与-POST-的区别？" class="headerlink" title="8）GET 与 POST 的区别？"></a>8）GET 与 POST 的区别？</h4><p>答：GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p><p>(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</p><p>(2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p><p>(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</p><p>(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</p><p>(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><p><strong>为什么在GET请求中会对URL进行编码？</strong><br>我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 <strong>避免歧义</strong>。看下面的例子，</p><p>针对 “name1=value1&amp;name2=value2” 的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为：</p><pre><code> 6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532 6E616D6531：name1  3D：=  76616C756531：value1  26：&amp; 6E616D6532：name2  3D：=  76616C756532：value2 </code></pre><p>服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p><p>现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p><p>那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</p><hr><h4 id="9）TCP与UDP的区别"><a href="#9）TCP与UDP的区别" class="headerlink" title="9）TCP与UDP的区别"></a>9）TCP与UDP的区别</h4><p>答：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p><ul><li><p>TCP是面向连接的，UDP是无连接的；</p></li><li><p>TCP是可靠的，UDP是不可靠的；</p></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；</p></li><li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p></li><li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p></li></ul><hr><h4 id="10）TCP和UDP分别对应的常见应用层协议"><a href="#10）TCP和UDP分别对应的常见应用层协议" class="headerlink" title="10）TCP和UDP分别对应的常见应用层协议"></a>10）TCP和UDP分别对应的常见应用层协议</h4><p>答：</p><p>(1). TCP 对应的应用层协议：</p><ul><li><p>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p></li><li><p>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p></li><li><p>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p></li><li><p>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p></li><li><p>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</p></li></ul><p>(2). UDP 对应的应用层协议：</p><ul><li><p>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p></li><li><p>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p></li><li><p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务</p></li></ul><p>(3). 图示：<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/4.png" alt></p><hr><h4 id="11）TCP-的拥塞避免机制"><a href="#11）TCP-的拥塞避免机制" class="headerlink" title="11）TCP 的拥塞避免机制"></a>11）TCP 的拥塞避免机制</h4><p>答：</p><p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p><p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p><p>拥塞控制的方法：</p><p><strong>(1). 慢启动 + 拥塞避免：</strong></p><p>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p><p>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p><p><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/5.png" alt></p><p><strong>(2). 快重传 + 快恢复：</strong></p><p>快重传：<strong>快重传</strong>要求接收方在收到一个 失序的报文段 后就立即发出** 重复确认<strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/6.png" alt><br>快恢复：</strong>快重传**配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/7.png" alt></p><hr><h4 id="12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。"><a href="#12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。" class="headerlink" title="12）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。"></a>12）浏览器中输入：“<a href="http://www.xxx.com”" target="_blank" rel="noopener">www.xxx.com”</a> 之后都发生了什么？请详细阐述。</h4><p>解析：经典的网络协议问题。</p><p>答：</p><ol><li>由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。</li><li>建立TCP/IP连接（三次握手具体过程）</li><li>由浏览器发送一个HTTP请求</li><li>经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器</li><li>服务器处理该HTTP请求，返回一个HTML文件</li><li>浏览器解析该HTML文件，并且显示在浏览器端</li><li>这里需要注意：<ul><li>HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接</li><li>可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li><li>两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</li></ul></li></ol><hr><h4 id="13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h4><p>答：HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。</p><p>HTTP 的这种特性有优点也有缺点：</p><ul><li>优点：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用</li><li>缺点：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享</li></ul><p>解决方案：</p><p>使用参数传递机制：</p><ul><li>将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：/param/list?username=wmyskxz</li></ul><p><strong>问题</strong>：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb</p><ul><li>使用 Cookie 技术</li><li>使用 Session 技术</li></ul><hr><h4 id="14）Session、Cookie-与-Application"><a href="#14）Session、Cookie-与-Application" class="headerlink" title="14）Session、Cookie 与 Application"></a>14）Session、Cookie 与 Application</h4><p>答：Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p><p><strong>(1). Cookie 及其相关 API ：</strong></p><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/8.png" alt><br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/9.png" alt><br><strong>(2). Session 及其相关 API：</strong></p><p>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用** cookie机制 <strong>，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 **URL重写</strong>机制 将sessionid传回服务器。<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/10.png" alt><br><strong>(3). Session 与 Cookie 的对比：</strong></p><ul><li><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p></li><li><p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p></li><li><p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p></li><li><p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p></li></ul><p><strong>(4). Application：</strong></p><p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p><hr><h4 id="15）滑动窗口机制"><a href="#15）滑动窗口机制" class="headerlink" title="15）滑动窗口机制"></a>15）滑动窗口机制</h4><p>答：由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。这就实现了流量的控制。</p><hr><h4 id="16）常用的HTTP方法有哪些？"><a href="#16）常用的HTTP方法有哪些？" class="headerlink" title="16）常用的HTTP方法有哪些？"></a>16）常用的HTTP方法有哪些？</h4><p>答：</p><ul><li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li><li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li><li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li><li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li><li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li><li>OPTIONS：查询相应URI支持的HTTP方法。</li></ul><hr><h4 id="17）常见HTTP状态码"><a href="#17）常见HTTP状态码" class="headerlink" title="17）常见HTTP状态码"></a>17）常见HTTP状态码</h4><p>答：</p><ul><li>1xx（临时响应）</li><li>2xx（成功）</li><li>3xx（重定向）：表示要完成请求需要进一步操作</li><li>4xx（错误）：表示请求可能出错，妨碍了服务器的处理</li><li>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误<br>常见状态码：<ol><li>200（成功）</li><li>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li><li>401（未授权）：请求要求身份验证</li><li>403（禁止）：服务器拒绝请求</li><li>404（未找到）：服务器找不到请求的网页</li></ol></li></ul><hr><h4 id="18）SQL-注入"><a href="#18）SQL-注入" class="headerlink" title="18）SQL 注入"></a>18）SQL 注入</h4><p>答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>(1).SQL注入攻击的总体思路：</p><ul><li>寻找到SQL注入的位置</li><li>判断服务器类型和后台数据库类型</li><li>针对不通的服务器和数据库特点进行SQL注入攻击</li></ul><p>(2). SQL注入攻击实例：</p><p>比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p><blockquote><p>用户名： ‘or 1 = 1 –<br>密 码：</p></blockquote><p>用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：</p><blockquote><p>String sql = “select * from user_table where username=’ “+userName+” ’ &gt; and password=’ “+password+” ‘”;</p></blockquote><p>因此，当输入了上面的用户名和密码，上面的SQL语句变成：</p><blockquote><p>SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’</p></blockquote><p>分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p><p>(3). 应对方法：</p><p>1.参数绑定：</p><p>使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。</p><p>2.使用正则表达式过滤传入的参数</p><hr><h4 id="19）XSS-攻击"><a href="#19）XSS-攻击" class="headerlink" title="19）XSS 攻击"></a>19）XSS 攻击</h4><p>答：XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p><p>(1). XSS攻击的危害：</p><ul><li><p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p></li><li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p></li><li><p>盗窃企业重要的具有商业价值的资料</p></li><li><p>非法转账</p></li><li><p>强制发送电子邮件</p></li><li><p>网站挂马</p></li><li><p>控制受害者机器向其它网站发起攻击</p></li></ul><p>(2). 原因解析：</p><ul><li>主要原因：过于信任客户端提交的数据！</li><li>解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。</li><li>进一步分析细节：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！</li></ul><p>(3). XSS 攻击分类：</p><ul><li>反射性 XSS 攻击（非持久性 XSS 攻击）：</li></ul><p>漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：</p><blockquote><p><a href="http://www.test.com/message.php?send=Hello,World！" target="_blank" rel="noopener">http://www.test.com/message.php?send=Hello,World！</a></p></blockquote><p>接收者将会接收信息并显示Hello,World；但是，非正常发送消息：</p><blockquote><p><a href="http://www.test.com/message.php?send=" target="_blank" rel="noopener">http://www.test.com/message.php?send=</a><script>alert(‘foolish!’)</script>！</p></blockquote><p>接收者接收消息显示的时候将会弹出警告窗口！</p><ul><li>持久性XSS攻击 (留言板场景)：</li></ul><p>XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p><p>例如，留言板表单中的表单域：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span>“text”</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span>“content”</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span>“这里是用户填写的数据”</span><span class="token punctuation">></span></span></code></pre><p>正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:</p><pre><code>&lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式）、一段攻击型代码--&gt;</code></pre><p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。</p><p>(4). 修复漏洞方针：</p><p>漏洞产生的根本原因是 太相信用户提交的数据，对用户所提交的数据过滤不足所导致的，因此解决方案也应该从这个方面入手，具体方案包括：</p><ul><li><p>将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；</p></li><li><p>表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。</p></li><li><p>对数据进行Html Encode 处理</p></li><li><p>过滤或移除特殊的Html标签，例如: , , &lt; for &lt;, &gt; for&gt;, &amp;quot for</p></li><li><p>过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。</p></li></ul><p>需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！</p><hr><h4 id="20）OSI-网络体系结构与-TCP-IP-协议模型"><a href="#20）OSI-网络体系结构与-TCP-IP-协议模型" class="headerlink" title="20）OSI 网络体系结构与 TCP/IP 协议模型"></a>20）OSI 网络体系结构与 TCP/IP 协议模型</h4><p>答：OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对 OSI 七层模型的各层进行简要的介绍：</p><h2 id><a href="#" class="headerlink" title></a><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/11.png" alt></h2><h6 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1). 物理层"></a>1). 物理层</h6><p>参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p><hr><h6 id="2-数据链路层（data-link-layer）"><a href="#2-数据链路层（data-link-layer）" class="headerlink" title="2). 数据链路层（data link layer）"></a>2). 数据链路层（data link layer）</h6><p>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><hr><h6 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3). 网络层"></a>3). 网络层</h6><p>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/12.png" alt></h2><h6 id="4-传输层（transport-layer）"><a href="#4-传输层（transport-layer）" class="headerlink" title="4). 传输层（transport layer）"></a>4). 传输层（transport layer）</h6><p>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。<br><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/13.png" alt><br>实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p><hr><p>5). 会话层（Session Layer）</p><p>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p><hr><p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p><p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><hr><p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p><hr><h4 id="21）网络层的-ARP-协议工作原理？"><a href="#21）网络层的-ARP-协议工作原理？" class="headerlink" title="21）网络层的 ARP 协议工作原理？"></a>21）网络层的 ARP 协议工作原理？</h4><p>答：地址解析协议(ARP) 是通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。</p><p><strong>网络层的ARP协议完成了IP地址与物理地址的映射。</strong>首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><hr><h4 id="22）IP地址的分类"><a href="#22）IP地址的分类" class="headerlink" title="22）IP地址的分类"></a>22）IP地址的分类</h4><p>答：整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p><p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p><ul><li>A类地址：以0开头，第一个字节范围：0~127；</li><li>B类地址：以10开头，第一个字节范围：128~191；</li><li>C类地址：以110开头，第一个字节范围：192~223；</li><li>D类地址：以1110开头，第一个字节范围为224~239；</li><li>E类地址：以1111开头，保留地址</li></ul><p><img src="http://cdn.cathetine.cn/blog/images/jisuanjiwangluo/14.png" alt></p><hr><p><strong>1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”</strong></p><p>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p><p>A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p><hr><p><strong>2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”</strong></p><p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p><p>B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p><hr><p><strong>3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”</strong></p><p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p><p>C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p><hr><p><strong>4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”</strong></p><p>　　D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。</p><hr><p><strong>5). E类地址:为保留地址，最高位必须是“1111”</strong></p><hr><h4 id="23）IP地址与物理地址"><a href="#23）IP地址与物理地址" class="headerlink" title="23）IP地址与物理地址"></a>23）IP地址与物理地址</h4><p>答：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p><hr><h4 id="24）影响网络传输的因素有哪些？"><a href="#24）影响网络传输的因素有哪些？" class="headerlink" title="24）影响网络传输的因素有哪些？"></a>24）影响网络传输的因素有哪些？</h4><p>答：将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。</p><ul><li><p>网络带宽：所谓带宽就是一条物理链路在 1s 内能够传输的最大比特数，注意这里是比特（bit）而不是字节数，也就是 b/s 。网络带宽肯定是影响数据传输的一个关键环节，因为在当前的网络环境中，平均网络带宽只有 1.7 MB/s 左右。</p></li><li><p>传输距离：也就是数据在光纤中要走的距离，虽然光的传播速度很快，但也是有时间的，由于数据在光纤中的移动并不是走直线的，会有一个折射率，所以大概是光的 2/3，这个时间也就是我们通常所说的传输延时。传输延时是一个无法避免的问题，例如，你要给在杭州和青岛的两个机房的一个数据库进行同步数据操作，那么必定会存在约 30ms 的一个延时。</p></li><li><p>TCP 拥塞控制：我们知道 TCP 传输是一个 “停-等-停-等” 的协议，传输方和接受方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP 在传输时会设定一个 “窗口”，这个窗口的大小是由带宽和 RTT（Round-Trip Time，数据在两端的来回时间，也就是响应时间）决定的。计算的公式是带宽（b/s）xRTT（s）。通过这个值就可以得出理论上最优的 TCP 缓冲区的大小。Linux 2.4 已经可以自动地调整发送端的缓冲区的大小，而到 Linux 2.6.7 时接收端也可以自动调整了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
